// Code generated by entproto. DO NOT EDIT.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.12.4
// source: entpb/entpb.proto

package entpb

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	AmazonListService_Create_FullMethodName      = "/entpb.AmazonListService/Create"
	AmazonListService_Get_FullMethodName         = "/entpb.AmazonListService/Get"
	AmazonListService_Update_FullMethodName      = "/entpb.AmazonListService/Update"
	AmazonListService_Delete_FullMethodName      = "/entpb.AmazonListService/Delete"
	AmazonListService_List_FullMethodName        = "/entpb.AmazonListService/List"
	AmazonListService_BatchCreate_FullMethodName = "/entpb.AmazonListService/BatchCreate"
)

// AmazonListServiceClient is the client API for AmazonListService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AmazonListServiceClient interface {
	Create(ctx context.Context, in *CreateAmazonListRequest, opts ...grpc.CallOption) (*AmazonList, error)
	Get(ctx context.Context, in *GetAmazonListRequest, opts ...grpc.CallOption) (*AmazonList, error)
	Update(ctx context.Context, in *UpdateAmazonListRequest, opts ...grpc.CallOption) (*AmazonList, error)
	Delete(ctx context.Context, in *DeleteAmazonListRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListAmazonListRequest, opts ...grpc.CallOption) (*ListAmazonListResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateAmazonListsRequest, opts ...grpc.CallOption) (*BatchCreateAmazonListsResponse, error)
}

type amazonListServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAmazonListServiceClient(cc grpc.ClientConnInterface) AmazonListServiceClient {
	return &amazonListServiceClient{cc}
}

func (c *amazonListServiceClient) Create(ctx context.Context, in *CreateAmazonListRequest, opts ...grpc.CallOption) (*AmazonList, error) {
	out := new(AmazonList)
	err := c.cc.Invoke(ctx, AmazonListService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonListServiceClient) Get(ctx context.Context, in *GetAmazonListRequest, opts ...grpc.CallOption) (*AmazonList, error) {
	out := new(AmazonList)
	err := c.cc.Invoke(ctx, AmazonListService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonListServiceClient) Update(ctx context.Context, in *UpdateAmazonListRequest, opts ...grpc.CallOption) (*AmazonList, error) {
	out := new(AmazonList)
	err := c.cc.Invoke(ctx, AmazonListService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonListServiceClient) Delete(ctx context.Context, in *DeleteAmazonListRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, AmazonListService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonListServiceClient) List(ctx context.Context, in *ListAmazonListRequest, opts ...grpc.CallOption) (*ListAmazonListResponse, error) {
	out := new(ListAmazonListResponse)
	err := c.cc.Invoke(ctx, AmazonListService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonListServiceClient) BatchCreate(ctx context.Context, in *BatchCreateAmazonListsRequest, opts ...grpc.CallOption) (*BatchCreateAmazonListsResponse, error) {
	out := new(BatchCreateAmazonListsResponse)
	err := c.cc.Invoke(ctx, AmazonListService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AmazonListServiceServer is the server API for AmazonListService service.
// All implementations must embed UnimplementedAmazonListServiceServer
// for forward compatibility
type AmazonListServiceServer interface {
	Create(context.Context, *CreateAmazonListRequest) (*AmazonList, error)
	Get(context.Context, *GetAmazonListRequest) (*AmazonList, error)
	Update(context.Context, *UpdateAmazonListRequest) (*AmazonList, error)
	Delete(context.Context, *DeleteAmazonListRequest) (*empty.Empty, error)
	List(context.Context, *ListAmazonListRequest) (*ListAmazonListResponse, error)
	BatchCreate(context.Context, *BatchCreateAmazonListsRequest) (*BatchCreateAmazonListsResponse, error)
	mustEmbedUnimplementedAmazonListServiceServer()
}

// UnimplementedAmazonListServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAmazonListServiceServer struct {
}

func (UnimplementedAmazonListServiceServer) Create(context.Context, *CreateAmazonListRequest) (*AmazonList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAmazonListServiceServer) Get(context.Context, *GetAmazonListRequest) (*AmazonList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAmazonListServiceServer) Update(context.Context, *UpdateAmazonListRequest) (*AmazonList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAmazonListServiceServer) Delete(context.Context, *DeleteAmazonListRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAmazonListServiceServer) List(context.Context, *ListAmazonListRequest) (*ListAmazonListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAmazonListServiceServer) BatchCreate(context.Context, *BatchCreateAmazonListsRequest) (*BatchCreateAmazonListsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedAmazonListServiceServer) mustEmbedUnimplementedAmazonListServiceServer() {}

// UnsafeAmazonListServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AmazonListServiceServer will
// result in compilation errors.
type UnsafeAmazonListServiceServer interface {
	mustEmbedUnimplementedAmazonListServiceServer()
}

func RegisterAmazonListServiceServer(s grpc.ServiceRegistrar, srv AmazonListServiceServer) {
	s.RegisterService(&AmazonListService_ServiceDesc, srv)
}

func _AmazonListService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAmazonListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonListServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonListService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonListServiceServer).Create(ctx, req.(*CreateAmazonListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonListService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAmazonListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonListServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonListService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonListServiceServer).Get(ctx, req.(*GetAmazonListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonListService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAmazonListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonListServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonListService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonListServiceServer).Update(ctx, req.(*UpdateAmazonListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonListService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAmazonListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonListServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonListService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonListServiceServer).Delete(ctx, req.(*DeleteAmazonListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonListService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAmazonListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonListServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonListService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonListServiceServer).List(ctx, req.(*ListAmazonListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonListService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateAmazonListsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonListServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonListService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonListServiceServer).BatchCreate(ctx, req.(*BatchCreateAmazonListsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AmazonListService_ServiceDesc is the grpc.ServiceDesc for AmazonListService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AmazonListService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.AmazonListService",
	HandlerType: (*AmazonListServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _AmazonListService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AmazonListService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AmazonListService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AmazonListService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _AmazonListService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _AmazonListService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	AmazonOrderService_Create_FullMethodName      = "/entpb.AmazonOrderService/Create"
	AmazonOrderService_Get_FullMethodName         = "/entpb.AmazonOrderService/Get"
	AmazonOrderService_Update_FullMethodName      = "/entpb.AmazonOrderService/Update"
	AmazonOrderService_Delete_FullMethodName      = "/entpb.AmazonOrderService/Delete"
	AmazonOrderService_List_FullMethodName        = "/entpb.AmazonOrderService/List"
	AmazonOrderService_BatchCreate_FullMethodName = "/entpb.AmazonOrderService/BatchCreate"
)

// AmazonOrderServiceClient is the client API for AmazonOrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AmazonOrderServiceClient interface {
	Create(ctx context.Context, in *CreateAmazonOrderRequest, opts ...grpc.CallOption) (*AmazonOrder, error)
	Get(ctx context.Context, in *GetAmazonOrderRequest, opts ...grpc.CallOption) (*AmazonOrder, error)
	Update(ctx context.Context, in *UpdateAmazonOrderRequest, opts ...grpc.CallOption) (*AmazonOrder, error)
	Delete(ctx context.Context, in *DeleteAmazonOrderRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListAmazonOrderRequest, opts ...grpc.CallOption) (*ListAmazonOrderResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateAmazonOrdersRequest, opts ...grpc.CallOption) (*BatchCreateAmazonOrdersResponse, error)
}

type amazonOrderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAmazonOrderServiceClient(cc grpc.ClientConnInterface) AmazonOrderServiceClient {
	return &amazonOrderServiceClient{cc}
}

func (c *amazonOrderServiceClient) Create(ctx context.Context, in *CreateAmazonOrderRequest, opts ...grpc.CallOption) (*AmazonOrder, error) {
	out := new(AmazonOrder)
	err := c.cc.Invoke(ctx, AmazonOrderService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonOrderServiceClient) Get(ctx context.Context, in *GetAmazonOrderRequest, opts ...grpc.CallOption) (*AmazonOrder, error) {
	out := new(AmazonOrder)
	err := c.cc.Invoke(ctx, AmazonOrderService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonOrderServiceClient) Update(ctx context.Context, in *UpdateAmazonOrderRequest, opts ...grpc.CallOption) (*AmazonOrder, error) {
	out := new(AmazonOrder)
	err := c.cc.Invoke(ctx, AmazonOrderService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonOrderServiceClient) Delete(ctx context.Context, in *DeleteAmazonOrderRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, AmazonOrderService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonOrderServiceClient) List(ctx context.Context, in *ListAmazonOrderRequest, opts ...grpc.CallOption) (*ListAmazonOrderResponse, error) {
	out := new(ListAmazonOrderResponse)
	err := c.cc.Invoke(ctx, AmazonOrderService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonOrderServiceClient) BatchCreate(ctx context.Context, in *BatchCreateAmazonOrdersRequest, opts ...grpc.CallOption) (*BatchCreateAmazonOrdersResponse, error) {
	out := new(BatchCreateAmazonOrdersResponse)
	err := c.cc.Invoke(ctx, AmazonOrderService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AmazonOrderServiceServer is the server API for AmazonOrderService service.
// All implementations must embed UnimplementedAmazonOrderServiceServer
// for forward compatibility
type AmazonOrderServiceServer interface {
	Create(context.Context, *CreateAmazonOrderRequest) (*AmazonOrder, error)
	Get(context.Context, *GetAmazonOrderRequest) (*AmazonOrder, error)
	Update(context.Context, *UpdateAmazonOrderRequest) (*AmazonOrder, error)
	Delete(context.Context, *DeleteAmazonOrderRequest) (*empty.Empty, error)
	List(context.Context, *ListAmazonOrderRequest) (*ListAmazonOrderResponse, error)
	BatchCreate(context.Context, *BatchCreateAmazonOrdersRequest) (*BatchCreateAmazonOrdersResponse, error)
	mustEmbedUnimplementedAmazonOrderServiceServer()
}

// UnimplementedAmazonOrderServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAmazonOrderServiceServer struct {
}

func (UnimplementedAmazonOrderServiceServer) Create(context.Context, *CreateAmazonOrderRequest) (*AmazonOrder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAmazonOrderServiceServer) Get(context.Context, *GetAmazonOrderRequest) (*AmazonOrder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAmazonOrderServiceServer) Update(context.Context, *UpdateAmazonOrderRequest) (*AmazonOrder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAmazonOrderServiceServer) Delete(context.Context, *DeleteAmazonOrderRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAmazonOrderServiceServer) List(context.Context, *ListAmazonOrderRequest) (*ListAmazonOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAmazonOrderServiceServer) BatchCreate(context.Context, *BatchCreateAmazonOrdersRequest) (*BatchCreateAmazonOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedAmazonOrderServiceServer) mustEmbedUnimplementedAmazonOrderServiceServer() {}

// UnsafeAmazonOrderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AmazonOrderServiceServer will
// result in compilation errors.
type UnsafeAmazonOrderServiceServer interface {
	mustEmbedUnimplementedAmazonOrderServiceServer()
}

func RegisterAmazonOrderServiceServer(s grpc.ServiceRegistrar, srv AmazonOrderServiceServer) {
	s.RegisterService(&AmazonOrderService_ServiceDesc, srv)
}

func _AmazonOrderService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAmazonOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonOrderServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonOrderService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonOrderServiceServer).Create(ctx, req.(*CreateAmazonOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonOrderService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAmazonOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonOrderServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonOrderService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonOrderServiceServer).Get(ctx, req.(*GetAmazonOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonOrderService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAmazonOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonOrderServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonOrderService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonOrderServiceServer).Update(ctx, req.(*UpdateAmazonOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonOrderService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAmazonOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonOrderServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonOrderService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonOrderServiceServer).Delete(ctx, req.(*DeleteAmazonOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonOrderService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAmazonOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonOrderServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonOrderService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonOrderServiceServer).List(ctx, req.(*ListAmazonOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonOrderService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateAmazonOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonOrderServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonOrderService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonOrderServiceServer).BatchCreate(ctx, req.(*BatchCreateAmazonOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AmazonOrderService_ServiceDesc is the grpc.ServiceDesc for AmazonOrderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AmazonOrderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.AmazonOrderService",
	HandlerType: (*AmazonOrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _AmazonOrderService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AmazonOrderService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AmazonOrderService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AmazonOrderService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _AmazonOrderService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _AmazonOrderService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	AmazonShareService_Create_FullMethodName      = "/entpb.AmazonShareService/Create"
	AmazonShareService_Get_FullMethodName         = "/entpb.AmazonShareService/Get"
	AmazonShareService_Update_FullMethodName      = "/entpb.AmazonShareService/Update"
	AmazonShareService_Delete_FullMethodName      = "/entpb.AmazonShareService/Delete"
	AmazonShareService_List_FullMethodName        = "/entpb.AmazonShareService/List"
	AmazonShareService_BatchCreate_FullMethodName = "/entpb.AmazonShareService/BatchCreate"
)

// AmazonShareServiceClient is the client API for AmazonShareService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AmazonShareServiceClient interface {
	Create(ctx context.Context, in *CreateAmazonShareRequest, opts ...grpc.CallOption) (*AmazonShare, error)
	Get(ctx context.Context, in *GetAmazonShareRequest, opts ...grpc.CallOption) (*AmazonShare, error)
	Update(ctx context.Context, in *UpdateAmazonShareRequest, opts ...grpc.CallOption) (*AmazonShare, error)
	Delete(ctx context.Context, in *DeleteAmazonShareRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListAmazonShareRequest, opts ...grpc.CallOption) (*ListAmazonShareResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateAmazonSharesRequest, opts ...grpc.CallOption) (*BatchCreateAmazonSharesResponse, error)
}

type amazonShareServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAmazonShareServiceClient(cc grpc.ClientConnInterface) AmazonShareServiceClient {
	return &amazonShareServiceClient{cc}
}

func (c *amazonShareServiceClient) Create(ctx context.Context, in *CreateAmazonShareRequest, opts ...grpc.CallOption) (*AmazonShare, error) {
	out := new(AmazonShare)
	err := c.cc.Invoke(ctx, AmazonShareService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonShareServiceClient) Get(ctx context.Context, in *GetAmazonShareRequest, opts ...grpc.CallOption) (*AmazonShare, error) {
	out := new(AmazonShare)
	err := c.cc.Invoke(ctx, AmazonShareService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonShareServiceClient) Update(ctx context.Context, in *UpdateAmazonShareRequest, opts ...grpc.CallOption) (*AmazonShare, error) {
	out := new(AmazonShare)
	err := c.cc.Invoke(ctx, AmazonShareService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonShareServiceClient) Delete(ctx context.Context, in *DeleteAmazonShareRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, AmazonShareService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonShareServiceClient) List(ctx context.Context, in *ListAmazonShareRequest, opts ...grpc.CallOption) (*ListAmazonShareResponse, error) {
	out := new(ListAmazonShareResponse)
	err := c.cc.Invoke(ctx, AmazonShareService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *amazonShareServiceClient) BatchCreate(ctx context.Context, in *BatchCreateAmazonSharesRequest, opts ...grpc.CallOption) (*BatchCreateAmazonSharesResponse, error) {
	out := new(BatchCreateAmazonSharesResponse)
	err := c.cc.Invoke(ctx, AmazonShareService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AmazonShareServiceServer is the server API for AmazonShareService service.
// All implementations must embed UnimplementedAmazonShareServiceServer
// for forward compatibility
type AmazonShareServiceServer interface {
	Create(context.Context, *CreateAmazonShareRequest) (*AmazonShare, error)
	Get(context.Context, *GetAmazonShareRequest) (*AmazonShare, error)
	Update(context.Context, *UpdateAmazonShareRequest) (*AmazonShare, error)
	Delete(context.Context, *DeleteAmazonShareRequest) (*empty.Empty, error)
	List(context.Context, *ListAmazonShareRequest) (*ListAmazonShareResponse, error)
	BatchCreate(context.Context, *BatchCreateAmazonSharesRequest) (*BatchCreateAmazonSharesResponse, error)
	mustEmbedUnimplementedAmazonShareServiceServer()
}

// UnimplementedAmazonShareServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAmazonShareServiceServer struct {
}

func (UnimplementedAmazonShareServiceServer) Create(context.Context, *CreateAmazonShareRequest) (*AmazonShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedAmazonShareServiceServer) Get(context.Context, *GetAmazonShareRequest) (*AmazonShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAmazonShareServiceServer) Update(context.Context, *UpdateAmazonShareRequest) (*AmazonShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAmazonShareServiceServer) Delete(context.Context, *DeleteAmazonShareRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAmazonShareServiceServer) List(context.Context, *ListAmazonShareRequest) (*ListAmazonShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAmazonShareServiceServer) BatchCreate(context.Context, *BatchCreateAmazonSharesRequest) (*BatchCreateAmazonSharesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedAmazonShareServiceServer) mustEmbedUnimplementedAmazonShareServiceServer() {}

// UnsafeAmazonShareServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AmazonShareServiceServer will
// result in compilation errors.
type UnsafeAmazonShareServiceServer interface {
	mustEmbedUnimplementedAmazonShareServiceServer()
}

func RegisterAmazonShareServiceServer(s grpc.ServiceRegistrar, srv AmazonShareServiceServer) {
	s.RegisterService(&AmazonShareService_ServiceDesc, srv)
}

func _AmazonShareService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAmazonShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonShareServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonShareService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonShareServiceServer).Create(ctx, req.(*CreateAmazonShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonShareService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAmazonShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonShareServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonShareService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonShareServiceServer).Get(ctx, req.(*GetAmazonShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonShareService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAmazonShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonShareServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonShareService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonShareServiceServer).Update(ctx, req.(*UpdateAmazonShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonShareService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAmazonShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonShareServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonShareService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonShareServiceServer).Delete(ctx, req.(*DeleteAmazonShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonShareService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAmazonShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonShareServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonShareService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonShareServiceServer).List(ctx, req.(*ListAmazonShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AmazonShareService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateAmazonSharesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AmazonShareServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AmazonShareService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AmazonShareServiceServer).BatchCreate(ctx, req.(*BatchCreateAmazonSharesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AmazonShareService_ServiceDesc is the grpc.ServiceDesc for AmazonShareService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AmazonShareService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.AmazonShareService",
	HandlerType: (*AmazonShareServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _AmazonShareService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AmazonShareService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AmazonShareService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AmazonShareService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _AmazonShareService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _AmazonShareService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	DrinkService_Create_FullMethodName      = "/entpb.DrinkService/Create"
	DrinkService_Get_FullMethodName         = "/entpb.DrinkService/Get"
	DrinkService_Update_FullMethodName      = "/entpb.DrinkService/Update"
	DrinkService_Delete_FullMethodName      = "/entpb.DrinkService/Delete"
	DrinkService_List_FullMethodName        = "/entpb.DrinkService/List"
	DrinkService_BatchCreate_FullMethodName = "/entpb.DrinkService/BatchCreate"
)

// DrinkServiceClient is the client API for DrinkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DrinkServiceClient interface {
	Create(ctx context.Context, in *CreateDrinkRequest, opts ...grpc.CallOption) (*Drink, error)
	Get(ctx context.Context, in *GetDrinkRequest, opts ...grpc.CallOption) (*Drink, error)
	Update(ctx context.Context, in *UpdateDrinkRequest, opts ...grpc.CallOption) (*Drink, error)
	Delete(ctx context.Context, in *DeleteDrinkRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListDrinkRequest, opts ...grpc.CallOption) (*ListDrinkResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateDrinksRequest, opts ...grpc.CallOption) (*BatchCreateDrinksResponse, error)
}

type drinkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDrinkServiceClient(cc grpc.ClientConnInterface) DrinkServiceClient {
	return &drinkServiceClient{cc}
}

func (c *drinkServiceClient) Create(ctx context.Context, in *CreateDrinkRequest, opts ...grpc.CallOption) (*Drink, error) {
	out := new(Drink)
	err := c.cc.Invoke(ctx, DrinkService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drinkServiceClient) Get(ctx context.Context, in *GetDrinkRequest, opts ...grpc.CallOption) (*Drink, error) {
	out := new(Drink)
	err := c.cc.Invoke(ctx, DrinkService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drinkServiceClient) Update(ctx context.Context, in *UpdateDrinkRequest, opts ...grpc.CallOption) (*Drink, error) {
	out := new(Drink)
	err := c.cc.Invoke(ctx, DrinkService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drinkServiceClient) Delete(ctx context.Context, in *DeleteDrinkRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, DrinkService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drinkServiceClient) List(ctx context.Context, in *ListDrinkRequest, opts ...grpc.CallOption) (*ListDrinkResponse, error) {
	out := new(ListDrinkResponse)
	err := c.cc.Invoke(ctx, DrinkService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *drinkServiceClient) BatchCreate(ctx context.Context, in *BatchCreateDrinksRequest, opts ...grpc.CallOption) (*BatchCreateDrinksResponse, error) {
	out := new(BatchCreateDrinksResponse)
	err := c.cc.Invoke(ctx, DrinkService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DrinkServiceServer is the server API for DrinkService service.
// All implementations must embed UnimplementedDrinkServiceServer
// for forward compatibility
type DrinkServiceServer interface {
	Create(context.Context, *CreateDrinkRequest) (*Drink, error)
	Get(context.Context, *GetDrinkRequest) (*Drink, error)
	Update(context.Context, *UpdateDrinkRequest) (*Drink, error)
	Delete(context.Context, *DeleteDrinkRequest) (*empty.Empty, error)
	List(context.Context, *ListDrinkRequest) (*ListDrinkResponse, error)
	BatchCreate(context.Context, *BatchCreateDrinksRequest) (*BatchCreateDrinksResponse, error)
	mustEmbedUnimplementedDrinkServiceServer()
}

// UnimplementedDrinkServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDrinkServiceServer struct {
}

func (UnimplementedDrinkServiceServer) Create(context.Context, *CreateDrinkRequest) (*Drink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDrinkServiceServer) Get(context.Context, *GetDrinkRequest) (*Drink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDrinkServiceServer) Update(context.Context, *UpdateDrinkRequest) (*Drink, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDrinkServiceServer) Delete(context.Context, *DeleteDrinkRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDrinkServiceServer) List(context.Context, *ListDrinkRequest) (*ListDrinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDrinkServiceServer) BatchCreate(context.Context, *BatchCreateDrinksRequest) (*BatchCreateDrinksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedDrinkServiceServer) mustEmbedUnimplementedDrinkServiceServer() {}

// UnsafeDrinkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DrinkServiceServer will
// result in compilation errors.
type UnsafeDrinkServiceServer interface {
	mustEmbedUnimplementedDrinkServiceServer()
}

func RegisterDrinkServiceServer(s grpc.ServiceRegistrar, srv DrinkServiceServer) {
	s.RegisterService(&DrinkService_ServiceDesc, srv)
}

func _DrinkService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDrinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrinkServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DrinkService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrinkServiceServer).Create(ctx, req.(*CreateDrinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DrinkService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDrinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrinkServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DrinkService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrinkServiceServer).Get(ctx, req.(*GetDrinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DrinkService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDrinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrinkServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DrinkService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrinkServiceServer).Update(ctx, req.(*UpdateDrinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DrinkService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDrinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrinkServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DrinkService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrinkServiceServer).Delete(ctx, req.(*DeleteDrinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DrinkService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDrinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrinkServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DrinkService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrinkServiceServer).List(ctx, req.(*ListDrinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DrinkService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateDrinksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DrinkServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DrinkService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DrinkServiceServer).BatchCreate(ctx, req.(*BatchCreateDrinksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DrinkService_ServiceDesc is the grpc.ServiceDesc for DrinkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DrinkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.DrinkService",
	HandlerType: (*DrinkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _DrinkService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DrinkService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DrinkService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DrinkService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DrinkService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _DrinkService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	GroceryListService_Create_FullMethodName      = "/entpb.GroceryListService/Create"
	GroceryListService_Get_FullMethodName         = "/entpb.GroceryListService/Get"
	GroceryListService_Update_FullMethodName      = "/entpb.GroceryListService/Update"
	GroceryListService_Delete_FullMethodName      = "/entpb.GroceryListService/Delete"
	GroceryListService_List_FullMethodName        = "/entpb.GroceryListService/List"
	GroceryListService_BatchCreate_FullMethodName = "/entpb.GroceryListService/BatchCreate"
)

// GroceryListServiceClient is the client API for GroceryListService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroceryListServiceClient interface {
	Create(ctx context.Context, in *CreateGroceryListRequest, opts ...grpc.CallOption) (*GroceryList, error)
	Get(ctx context.Context, in *GetGroceryListRequest, opts ...grpc.CallOption) (*GroceryList, error)
	Update(ctx context.Context, in *UpdateGroceryListRequest, opts ...grpc.CallOption) (*GroceryList, error)
	Delete(ctx context.Context, in *DeleteGroceryListRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListGroceryListRequest, opts ...grpc.CallOption) (*ListGroceryListResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateGroceryListsRequest, opts ...grpc.CallOption) (*BatchCreateGroceryListsResponse, error)
}

type groceryListServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGroceryListServiceClient(cc grpc.ClientConnInterface) GroceryListServiceClient {
	return &groceryListServiceClient{cc}
}

func (c *groceryListServiceClient) Create(ctx context.Context, in *CreateGroceryListRequest, opts ...grpc.CallOption) (*GroceryList, error) {
	out := new(GroceryList)
	err := c.cc.Invoke(ctx, GroceryListService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListServiceClient) Get(ctx context.Context, in *GetGroceryListRequest, opts ...grpc.CallOption) (*GroceryList, error) {
	out := new(GroceryList)
	err := c.cc.Invoke(ctx, GroceryListService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListServiceClient) Update(ctx context.Context, in *UpdateGroceryListRequest, opts ...grpc.CallOption) (*GroceryList, error) {
	out := new(GroceryList)
	err := c.cc.Invoke(ctx, GroceryListService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListServiceClient) Delete(ctx context.Context, in *DeleteGroceryListRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, GroceryListService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListServiceClient) List(ctx context.Context, in *ListGroceryListRequest, opts ...grpc.CallOption) (*ListGroceryListResponse, error) {
	out := new(ListGroceryListResponse)
	err := c.cc.Invoke(ctx, GroceryListService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListServiceClient) BatchCreate(ctx context.Context, in *BatchCreateGroceryListsRequest, opts ...grpc.CallOption) (*BatchCreateGroceryListsResponse, error) {
	out := new(BatchCreateGroceryListsResponse)
	err := c.cc.Invoke(ctx, GroceryListService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroceryListServiceServer is the server API for GroceryListService service.
// All implementations must embed UnimplementedGroceryListServiceServer
// for forward compatibility
type GroceryListServiceServer interface {
	Create(context.Context, *CreateGroceryListRequest) (*GroceryList, error)
	Get(context.Context, *GetGroceryListRequest) (*GroceryList, error)
	Update(context.Context, *UpdateGroceryListRequest) (*GroceryList, error)
	Delete(context.Context, *DeleteGroceryListRequest) (*empty.Empty, error)
	List(context.Context, *ListGroceryListRequest) (*ListGroceryListResponse, error)
	BatchCreate(context.Context, *BatchCreateGroceryListsRequest) (*BatchCreateGroceryListsResponse, error)
	mustEmbedUnimplementedGroceryListServiceServer()
}

// UnimplementedGroceryListServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGroceryListServiceServer struct {
}

func (UnimplementedGroceryListServiceServer) Create(context.Context, *CreateGroceryListRequest) (*GroceryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedGroceryListServiceServer) Get(context.Context, *GetGroceryListRequest) (*GroceryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGroceryListServiceServer) Update(context.Context, *UpdateGroceryListRequest) (*GroceryList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedGroceryListServiceServer) Delete(context.Context, *DeleteGroceryListRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGroceryListServiceServer) List(context.Context, *ListGroceryListRequest) (*ListGroceryListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedGroceryListServiceServer) BatchCreate(context.Context, *BatchCreateGroceryListsRequest) (*BatchCreateGroceryListsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedGroceryListServiceServer) mustEmbedUnimplementedGroceryListServiceServer() {}

// UnsafeGroceryListServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroceryListServiceServer will
// result in compilation errors.
type UnsafeGroceryListServiceServer interface {
	mustEmbedUnimplementedGroceryListServiceServer()
}

func RegisterGroceryListServiceServer(s grpc.ServiceRegistrar, srv GroceryListServiceServer) {
	s.RegisterService(&GroceryListService_ServiceDesc, srv)
}

func _GroceryListService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroceryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListServiceServer).Create(ctx, req.(*CreateGroceryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroceryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListServiceServer).Get(ctx, req.(*GetGroceryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroceryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListServiceServer).Update(ctx, req.(*UpdateGroceryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroceryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListServiceServer).Delete(ctx, req.(*DeleteGroceryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroceryListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListServiceServer).List(ctx, req.(*ListGroceryListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateGroceryListsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListServiceServer).BatchCreate(ctx, req.(*BatchCreateGroceryListsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GroceryListService_ServiceDesc is the grpc.ServiceDesc for GroceryListService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroceryListService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.GroceryListService",
	HandlerType: (*GroceryListServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _GroceryListService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GroceryListService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _GroceryListService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GroceryListService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GroceryListService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _GroceryListService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	GroceryListItemService_Create_FullMethodName      = "/entpb.GroceryListItemService/Create"
	GroceryListItemService_Get_FullMethodName         = "/entpb.GroceryListItemService/Get"
	GroceryListItemService_Update_FullMethodName      = "/entpb.GroceryListItemService/Update"
	GroceryListItemService_Delete_FullMethodName      = "/entpb.GroceryListItemService/Delete"
	GroceryListItemService_List_FullMethodName        = "/entpb.GroceryListItemService/List"
	GroceryListItemService_BatchCreate_FullMethodName = "/entpb.GroceryListItemService/BatchCreate"
)

// GroceryListItemServiceClient is the client API for GroceryListItemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroceryListItemServiceClient interface {
	Create(ctx context.Context, in *CreateGroceryListItemRequest, opts ...grpc.CallOption) (*GroceryListItem, error)
	Get(ctx context.Context, in *GetGroceryListItemRequest, opts ...grpc.CallOption) (*GroceryListItem, error)
	Update(ctx context.Context, in *UpdateGroceryListItemRequest, opts ...grpc.CallOption) (*GroceryListItem, error)
	Delete(ctx context.Context, in *DeleteGroceryListItemRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListGroceryListItemRequest, opts ...grpc.CallOption) (*ListGroceryListItemResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateGroceryListItemsRequest, opts ...grpc.CallOption) (*BatchCreateGroceryListItemsResponse, error)
}

type groceryListItemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGroceryListItemServiceClient(cc grpc.ClientConnInterface) GroceryListItemServiceClient {
	return &groceryListItemServiceClient{cc}
}

func (c *groceryListItemServiceClient) Create(ctx context.Context, in *CreateGroceryListItemRequest, opts ...grpc.CallOption) (*GroceryListItem, error) {
	out := new(GroceryListItem)
	err := c.cc.Invoke(ctx, GroceryListItemService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListItemServiceClient) Get(ctx context.Context, in *GetGroceryListItemRequest, opts ...grpc.CallOption) (*GroceryListItem, error) {
	out := new(GroceryListItem)
	err := c.cc.Invoke(ctx, GroceryListItemService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListItemServiceClient) Update(ctx context.Context, in *UpdateGroceryListItemRequest, opts ...grpc.CallOption) (*GroceryListItem, error) {
	out := new(GroceryListItem)
	err := c.cc.Invoke(ctx, GroceryListItemService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListItemServiceClient) Delete(ctx context.Context, in *DeleteGroceryListItemRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, GroceryListItemService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListItemServiceClient) List(ctx context.Context, in *ListGroceryListItemRequest, opts ...grpc.CallOption) (*ListGroceryListItemResponse, error) {
	out := new(ListGroceryListItemResponse)
	err := c.cc.Invoke(ctx, GroceryListItemService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListItemServiceClient) BatchCreate(ctx context.Context, in *BatchCreateGroceryListItemsRequest, opts ...grpc.CallOption) (*BatchCreateGroceryListItemsResponse, error) {
	out := new(BatchCreateGroceryListItemsResponse)
	err := c.cc.Invoke(ctx, GroceryListItemService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroceryListItemServiceServer is the server API for GroceryListItemService service.
// All implementations must embed UnimplementedGroceryListItemServiceServer
// for forward compatibility
type GroceryListItemServiceServer interface {
	Create(context.Context, *CreateGroceryListItemRequest) (*GroceryListItem, error)
	Get(context.Context, *GetGroceryListItemRequest) (*GroceryListItem, error)
	Update(context.Context, *UpdateGroceryListItemRequest) (*GroceryListItem, error)
	Delete(context.Context, *DeleteGroceryListItemRequest) (*empty.Empty, error)
	List(context.Context, *ListGroceryListItemRequest) (*ListGroceryListItemResponse, error)
	BatchCreate(context.Context, *BatchCreateGroceryListItemsRequest) (*BatchCreateGroceryListItemsResponse, error)
	mustEmbedUnimplementedGroceryListItemServiceServer()
}

// UnimplementedGroceryListItemServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGroceryListItemServiceServer struct {
}

func (UnimplementedGroceryListItemServiceServer) Create(context.Context, *CreateGroceryListItemRequest) (*GroceryListItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedGroceryListItemServiceServer) Get(context.Context, *GetGroceryListItemRequest) (*GroceryListItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGroceryListItemServiceServer) Update(context.Context, *UpdateGroceryListItemRequest) (*GroceryListItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedGroceryListItemServiceServer) Delete(context.Context, *DeleteGroceryListItemRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGroceryListItemServiceServer) List(context.Context, *ListGroceryListItemRequest) (*ListGroceryListItemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedGroceryListItemServiceServer) BatchCreate(context.Context, *BatchCreateGroceryListItemsRequest) (*BatchCreateGroceryListItemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedGroceryListItemServiceServer) mustEmbedUnimplementedGroceryListItemServiceServer() {
}

// UnsafeGroceryListItemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroceryListItemServiceServer will
// result in compilation errors.
type UnsafeGroceryListItemServiceServer interface {
	mustEmbedUnimplementedGroceryListItemServiceServer()
}

func RegisterGroceryListItemServiceServer(s grpc.ServiceRegistrar, srv GroceryListItemServiceServer) {
	s.RegisterService(&GroceryListItemService_ServiceDesc, srv)
}

func _GroceryListItemService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroceryListItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListItemServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListItemService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListItemServiceServer).Create(ctx, req.(*CreateGroceryListItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListItemService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroceryListItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListItemServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListItemService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListItemServiceServer).Get(ctx, req.(*GetGroceryListItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListItemService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroceryListItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListItemServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListItemService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListItemServiceServer).Update(ctx, req.(*UpdateGroceryListItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListItemService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroceryListItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListItemServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListItemService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListItemServiceServer).Delete(ctx, req.(*DeleteGroceryListItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListItemService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroceryListItemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListItemServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListItemService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListItemServiceServer).List(ctx, req.(*ListGroceryListItemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListItemService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateGroceryListItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListItemServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListItemService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListItemServiceServer).BatchCreate(ctx, req.(*BatchCreateGroceryListItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GroceryListItemService_ServiceDesc is the grpc.ServiceDesc for GroceryListItemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroceryListItemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.GroceryListItemService",
	HandlerType: (*GroceryListItemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _GroceryListItemService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GroceryListItemService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _GroceryListItemService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GroceryListItemService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GroceryListItemService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _GroceryListItemService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	GroceryListShareService_Create_FullMethodName      = "/entpb.GroceryListShareService/Create"
	GroceryListShareService_Get_FullMethodName         = "/entpb.GroceryListShareService/Get"
	GroceryListShareService_Update_FullMethodName      = "/entpb.GroceryListShareService/Update"
	GroceryListShareService_Delete_FullMethodName      = "/entpb.GroceryListShareService/Delete"
	GroceryListShareService_List_FullMethodName        = "/entpb.GroceryListShareService/List"
	GroceryListShareService_BatchCreate_FullMethodName = "/entpb.GroceryListShareService/BatchCreate"
)

// GroceryListShareServiceClient is the client API for GroceryListShareService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroceryListShareServiceClient interface {
	Create(ctx context.Context, in *CreateGroceryListShareRequest, opts ...grpc.CallOption) (*GroceryListShare, error)
	Get(ctx context.Context, in *GetGroceryListShareRequest, opts ...grpc.CallOption) (*GroceryListShare, error)
	Update(ctx context.Context, in *UpdateGroceryListShareRequest, opts ...grpc.CallOption) (*GroceryListShare, error)
	Delete(ctx context.Context, in *DeleteGroceryListShareRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListGroceryListShareRequest, opts ...grpc.CallOption) (*ListGroceryListShareResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateGroceryListSharesRequest, opts ...grpc.CallOption) (*BatchCreateGroceryListSharesResponse, error)
}

type groceryListShareServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGroceryListShareServiceClient(cc grpc.ClientConnInterface) GroceryListShareServiceClient {
	return &groceryListShareServiceClient{cc}
}

func (c *groceryListShareServiceClient) Create(ctx context.Context, in *CreateGroceryListShareRequest, opts ...grpc.CallOption) (*GroceryListShare, error) {
	out := new(GroceryListShare)
	err := c.cc.Invoke(ctx, GroceryListShareService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListShareServiceClient) Get(ctx context.Context, in *GetGroceryListShareRequest, opts ...grpc.CallOption) (*GroceryListShare, error) {
	out := new(GroceryListShare)
	err := c.cc.Invoke(ctx, GroceryListShareService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListShareServiceClient) Update(ctx context.Context, in *UpdateGroceryListShareRequest, opts ...grpc.CallOption) (*GroceryListShare, error) {
	out := new(GroceryListShare)
	err := c.cc.Invoke(ctx, GroceryListShareService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListShareServiceClient) Delete(ctx context.Context, in *DeleteGroceryListShareRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, GroceryListShareService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListShareServiceClient) List(ctx context.Context, in *ListGroceryListShareRequest, opts ...grpc.CallOption) (*ListGroceryListShareResponse, error) {
	out := new(ListGroceryListShareResponse)
	err := c.cc.Invoke(ctx, GroceryListShareService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groceryListShareServiceClient) BatchCreate(ctx context.Context, in *BatchCreateGroceryListSharesRequest, opts ...grpc.CallOption) (*BatchCreateGroceryListSharesResponse, error) {
	out := new(BatchCreateGroceryListSharesResponse)
	err := c.cc.Invoke(ctx, GroceryListShareService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroceryListShareServiceServer is the server API for GroceryListShareService service.
// All implementations must embed UnimplementedGroceryListShareServiceServer
// for forward compatibility
type GroceryListShareServiceServer interface {
	Create(context.Context, *CreateGroceryListShareRequest) (*GroceryListShare, error)
	Get(context.Context, *GetGroceryListShareRequest) (*GroceryListShare, error)
	Update(context.Context, *UpdateGroceryListShareRequest) (*GroceryListShare, error)
	Delete(context.Context, *DeleteGroceryListShareRequest) (*empty.Empty, error)
	List(context.Context, *ListGroceryListShareRequest) (*ListGroceryListShareResponse, error)
	BatchCreate(context.Context, *BatchCreateGroceryListSharesRequest) (*BatchCreateGroceryListSharesResponse, error)
	mustEmbedUnimplementedGroceryListShareServiceServer()
}

// UnimplementedGroceryListShareServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGroceryListShareServiceServer struct {
}

func (UnimplementedGroceryListShareServiceServer) Create(context.Context, *CreateGroceryListShareRequest) (*GroceryListShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedGroceryListShareServiceServer) Get(context.Context, *GetGroceryListShareRequest) (*GroceryListShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGroceryListShareServiceServer) Update(context.Context, *UpdateGroceryListShareRequest) (*GroceryListShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedGroceryListShareServiceServer) Delete(context.Context, *DeleteGroceryListShareRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGroceryListShareServiceServer) List(context.Context, *ListGroceryListShareRequest) (*ListGroceryListShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedGroceryListShareServiceServer) BatchCreate(context.Context, *BatchCreateGroceryListSharesRequest) (*BatchCreateGroceryListSharesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedGroceryListShareServiceServer) mustEmbedUnimplementedGroceryListShareServiceServer() {
}

// UnsafeGroceryListShareServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroceryListShareServiceServer will
// result in compilation errors.
type UnsafeGroceryListShareServiceServer interface {
	mustEmbedUnimplementedGroceryListShareServiceServer()
}

func RegisterGroceryListShareServiceServer(s grpc.ServiceRegistrar, srv GroceryListShareServiceServer) {
	s.RegisterService(&GroceryListShareService_ServiceDesc, srv)
}

func _GroceryListShareService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroceryListShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListShareServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListShareService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListShareServiceServer).Create(ctx, req.(*CreateGroceryListShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListShareService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroceryListShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListShareServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListShareService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListShareServiceServer).Get(ctx, req.(*GetGroceryListShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListShareService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroceryListShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListShareServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListShareService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListShareServiceServer).Update(ctx, req.(*UpdateGroceryListShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListShareService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroceryListShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListShareServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListShareService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListShareServiceServer).Delete(ctx, req.(*DeleteGroceryListShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListShareService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroceryListShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListShareServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListShareService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListShareServiceServer).List(ctx, req.(*ListGroceryListShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroceryListShareService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateGroceryListSharesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroceryListShareServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroceryListShareService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroceryListShareServiceServer).BatchCreate(ctx, req.(*BatchCreateGroceryListSharesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GroceryListShareService_ServiceDesc is the grpc.ServiceDesc for GroceryListShareService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroceryListShareService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.GroceryListShareService",
	HandlerType: (*GroceryListShareServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _GroceryListShareService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GroceryListShareService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _GroceryListShareService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GroceryListShareService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GroceryListShareService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _GroceryListShareService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	MovieService_Create_FullMethodName      = "/entpb.MovieService/Create"
	MovieService_Get_FullMethodName         = "/entpb.MovieService/Get"
	MovieService_Update_FullMethodName      = "/entpb.MovieService/Update"
	MovieService_Delete_FullMethodName      = "/entpb.MovieService/Delete"
	MovieService_List_FullMethodName        = "/entpb.MovieService/List"
	MovieService_BatchCreate_FullMethodName = "/entpb.MovieService/BatchCreate"
)

// MovieServiceClient is the client API for MovieService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MovieServiceClient interface {
	Create(ctx context.Context, in *CreateMovieRequest, opts ...grpc.CallOption) (*Movie, error)
	Get(ctx context.Context, in *GetMovieRequest, opts ...grpc.CallOption) (*Movie, error)
	Update(ctx context.Context, in *UpdateMovieRequest, opts ...grpc.CallOption) (*Movie, error)
	Delete(ctx context.Context, in *DeleteMovieRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListMovieRequest, opts ...grpc.CallOption) (*ListMovieResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateMoviesRequest, opts ...grpc.CallOption) (*BatchCreateMoviesResponse, error)
}

type movieServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMovieServiceClient(cc grpc.ClientConnInterface) MovieServiceClient {
	return &movieServiceClient{cc}
}

func (c *movieServiceClient) Create(ctx context.Context, in *CreateMovieRequest, opts ...grpc.CallOption) (*Movie, error) {
	out := new(Movie)
	err := c.cc.Invoke(ctx, MovieService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieServiceClient) Get(ctx context.Context, in *GetMovieRequest, opts ...grpc.CallOption) (*Movie, error) {
	out := new(Movie)
	err := c.cc.Invoke(ctx, MovieService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieServiceClient) Update(ctx context.Context, in *UpdateMovieRequest, opts ...grpc.CallOption) (*Movie, error) {
	out := new(Movie)
	err := c.cc.Invoke(ctx, MovieService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieServiceClient) Delete(ctx context.Context, in *DeleteMovieRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MovieService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieServiceClient) List(ctx context.Context, in *ListMovieRequest, opts ...grpc.CallOption) (*ListMovieResponse, error) {
	out := new(ListMovieResponse)
	err := c.cc.Invoke(ctx, MovieService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieServiceClient) BatchCreate(ctx context.Context, in *BatchCreateMoviesRequest, opts ...grpc.CallOption) (*BatchCreateMoviesResponse, error) {
	out := new(BatchCreateMoviesResponse)
	err := c.cc.Invoke(ctx, MovieService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MovieServiceServer is the server API for MovieService service.
// All implementations must embed UnimplementedMovieServiceServer
// for forward compatibility
type MovieServiceServer interface {
	Create(context.Context, *CreateMovieRequest) (*Movie, error)
	Get(context.Context, *GetMovieRequest) (*Movie, error)
	Update(context.Context, *UpdateMovieRequest) (*Movie, error)
	Delete(context.Context, *DeleteMovieRequest) (*empty.Empty, error)
	List(context.Context, *ListMovieRequest) (*ListMovieResponse, error)
	BatchCreate(context.Context, *BatchCreateMoviesRequest) (*BatchCreateMoviesResponse, error)
	mustEmbedUnimplementedMovieServiceServer()
}

// UnimplementedMovieServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMovieServiceServer struct {
}

func (UnimplementedMovieServiceServer) Create(context.Context, *CreateMovieRequest) (*Movie, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedMovieServiceServer) Get(context.Context, *GetMovieRequest) (*Movie, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMovieServiceServer) Update(context.Context, *UpdateMovieRequest) (*Movie, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedMovieServiceServer) Delete(context.Context, *DeleteMovieRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMovieServiceServer) List(context.Context, *ListMovieRequest) (*ListMovieResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMovieServiceServer) BatchCreate(context.Context, *BatchCreateMoviesRequest) (*BatchCreateMoviesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedMovieServiceServer) mustEmbedUnimplementedMovieServiceServer() {}

// UnsafeMovieServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MovieServiceServer will
// result in compilation errors.
type UnsafeMovieServiceServer interface {
	mustEmbedUnimplementedMovieServiceServer()
}

func RegisterMovieServiceServer(s grpc.ServiceRegistrar, srv MovieServiceServer) {
	s.RegisterService(&MovieService_ServiceDesc, srv)
}

func _MovieService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMovieRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieServiceServer).Create(ctx, req.(*CreateMovieRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMovieRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieServiceServer).Get(ctx, req.(*GetMovieRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMovieRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieServiceServer).Update(ctx, req.(*UpdateMovieRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMovieRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieServiceServer).Delete(ctx, req.(*DeleteMovieRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMovieRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieServiceServer).List(ctx, req.(*ListMovieRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateMoviesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieServiceServer).BatchCreate(ctx, req.(*BatchCreateMoviesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MovieService_ServiceDesc is the grpc.ServiceDesc for MovieService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MovieService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.MovieService",
	HandlerType: (*MovieServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _MovieService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MovieService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _MovieService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MovieService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MovieService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _MovieService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	MovieCollectionService_Create_FullMethodName      = "/entpb.MovieCollectionService/Create"
	MovieCollectionService_Get_FullMethodName         = "/entpb.MovieCollectionService/Get"
	MovieCollectionService_Update_FullMethodName      = "/entpb.MovieCollectionService/Update"
	MovieCollectionService_Delete_FullMethodName      = "/entpb.MovieCollectionService/Delete"
	MovieCollectionService_List_FullMethodName        = "/entpb.MovieCollectionService/List"
	MovieCollectionService_BatchCreate_FullMethodName = "/entpb.MovieCollectionService/BatchCreate"
)

// MovieCollectionServiceClient is the client API for MovieCollectionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MovieCollectionServiceClient interface {
	Create(ctx context.Context, in *CreateMovieCollectionRequest, opts ...grpc.CallOption) (*MovieCollection, error)
	Get(ctx context.Context, in *GetMovieCollectionRequest, opts ...grpc.CallOption) (*MovieCollection, error)
	Update(ctx context.Context, in *UpdateMovieCollectionRequest, opts ...grpc.CallOption) (*MovieCollection, error)
	Delete(ctx context.Context, in *DeleteMovieCollectionRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListMovieCollectionRequest, opts ...grpc.CallOption) (*ListMovieCollectionResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateMovieCollectionsRequest, opts ...grpc.CallOption) (*BatchCreateMovieCollectionsResponse, error)
}

type movieCollectionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMovieCollectionServiceClient(cc grpc.ClientConnInterface) MovieCollectionServiceClient {
	return &movieCollectionServiceClient{cc}
}

func (c *movieCollectionServiceClient) Create(ctx context.Context, in *CreateMovieCollectionRequest, opts ...grpc.CallOption) (*MovieCollection, error) {
	out := new(MovieCollection)
	err := c.cc.Invoke(ctx, MovieCollectionService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionServiceClient) Get(ctx context.Context, in *GetMovieCollectionRequest, opts ...grpc.CallOption) (*MovieCollection, error) {
	out := new(MovieCollection)
	err := c.cc.Invoke(ctx, MovieCollectionService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionServiceClient) Update(ctx context.Context, in *UpdateMovieCollectionRequest, opts ...grpc.CallOption) (*MovieCollection, error) {
	out := new(MovieCollection)
	err := c.cc.Invoke(ctx, MovieCollectionService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionServiceClient) Delete(ctx context.Context, in *DeleteMovieCollectionRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MovieCollectionService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionServiceClient) List(ctx context.Context, in *ListMovieCollectionRequest, opts ...grpc.CallOption) (*ListMovieCollectionResponse, error) {
	out := new(ListMovieCollectionResponse)
	err := c.cc.Invoke(ctx, MovieCollectionService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionServiceClient) BatchCreate(ctx context.Context, in *BatchCreateMovieCollectionsRequest, opts ...grpc.CallOption) (*BatchCreateMovieCollectionsResponse, error) {
	out := new(BatchCreateMovieCollectionsResponse)
	err := c.cc.Invoke(ctx, MovieCollectionService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MovieCollectionServiceServer is the server API for MovieCollectionService service.
// All implementations must embed UnimplementedMovieCollectionServiceServer
// for forward compatibility
type MovieCollectionServiceServer interface {
	Create(context.Context, *CreateMovieCollectionRequest) (*MovieCollection, error)
	Get(context.Context, *GetMovieCollectionRequest) (*MovieCollection, error)
	Update(context.Context, *UpdateMovieCollectionRequest) (*MovieCollection, error)
	Delete(context.Context, *DeleteMovieCollectionRequest) (*empty.Empty, error)
	List(context.Context, *ListMovieCollectionRequest) (*ListMovieCollectionResponse, error)
	BatchCreate(context.Context, *BatchCreateMovieCollectionsRequest) (*BatchCreateMovieCollectionsResponse, error)
	mustEmbedUnimplementedMovieCollectionServiceServer()
}

// UnimplementedMovieCollectionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMovieCollectionServiceServer struct {
}

func (UnimplementedMovieCollectionServiceServer) Create(context.Context, *CreateMovieCollectionRequest) (*MovieCollection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedMovieCollectionServiceServer) Get(context.Context, *GetMovieCollectionRequest) (*MovieCollection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMovieCollectionServiceServer) Update(context.Context, *UpdateMovieCollectionRequest) (*MovieCollection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedMovieCollectionServiceServer) Delete(context.Context, *DeleteMovieCollectionRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMovieCollectionServiceServer) List(context.Context, *ListMovieCollectionRequest) (*ListMovieCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMovieCollectionServiceServer) BatchCreate(context.Context, *BatchCreateMovieCollectionsRequest) (*BatchCreateMovieCollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedMovieCollectionServiceServer) mustEmbedUnimplementedMovieCollectionServiceServer() {
}

// UnsafeMovieCollectionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MovieCollectionServiceServer will
// result in compilation errors.
type UnsafeMovieCollectionServiceServer interface {
	mustEmbedUnimplementedMovieCollectionServiceServer()
}

func RegisterMovieCollectionServiceServer(s grpc.ServiceRegistrar, srv MovieCollectionServiceServer) {
	s.RegisterService(&MovieCollectionService_ServiceDesc, srv)
}

func _MovieCollectionService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMovieCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionServiceServer).Create(ctx, req.(*CreateMovieCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMovieCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionServiceServer).Get(ctx, req.(*GetMovieCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMovieCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionServiceServer).Update(ctx, req.(*UpdateMovieCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMovieCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionServiceServer).Delete(ctx, req.(*DeleteMovieCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMovieCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionServiceServer).List(ctx, req.(*ListMovieCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateMovieCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionServiceServer).BatchCreate(ctx, req.(*BatchCreateMovieCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MovieCollectionService_ServiceDesc is the grpc.ServiceDesc for MovieCollectionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MovieCollectionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.MovieCollectionService",
	HandlerType: (*MovieCollectionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _MovieCollectionService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MovieCollectionService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _MovieCollectionService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MovieCollectionService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MovieCollectionService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _MovieCollectionService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	MovieCollectionShareService_Create_FullMethodName      = "/entpb.MovieCollectionShareService/Create"
	MovieCollectionShareService_Get_FullMethodName         = "/entpb.MovieCollectionShareService/Get"
	MovieCollectionShareService_Update_FullMethodName      = "/entpb.MovieCollectionShareService/Update"
	MovieCollectionShareService_Delete_FullMethodName      = "/entpb.MovieCollectionShareService/Delete"
	MovieCollectionShareService_List_FullMethodName        = "/entpb.MovieCollectionShareService/List"
	MovieCollectionShareService_BatchCreate_FullMethodName = "/entpb.MovieCollectionShareService/BatchCreate"
)

// MovieCollectionShareServiceClient is the client API for MovieCollectionShareService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MovieCollectionShareServiceClient interface {
	Create(ctx context.Context, in *CreateMovieCollectionShareRequest, opts ...grpc.CallOption) (*MovieCollectionShare, error)
	Get(ctx context.Context, in *GetMovieCollectionShareRequest, opts ...grpc.CallOption) (*MovieCollectionShare, error)
	Update(ctx context.Context, in *UpdateMovieCollectionShareRequest, opts ...grpc.CallOption) (*MovieCollectionShare, error)
	Delete(ctx context.Context, in *DeleteMovieCollectionShareRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListMovieCollectionShareRequest, opts ...grpc.CallOption) (*ListMovieCollectionShareResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateMovieCollectionSharesRequest, opts ...grpc.CallOption) (*BatchCreateMovieCollectionSharesResponse, error)
}

type movieCollectionShareServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMovieCollectionShareServiceClient(cc grpc.ClientConnInterface) MovieCollectionShareServiceClient {
	return &movieCollectionShareServiceClient{cc}
}

func (c *movieCollectionShareServiceClient) Create(ctx context.Context, in *CreateMovieCollectionShareRequest, opts ...grpc.CallOption) (*MovieCollectionShare, error) {
	out := new(MovieCollectionShare)
	err := c.cc.Invoke(ctx, MovieCollectionShareService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionShareServiceClient) Get(ctx context.Context, in *GetMovieCollectionShareRequest, opts ...grpc.CallOption) (*MovieCollectionShare, error) {
	out := new(MovieCollectionShare)
	err := c.cc.Invoke(ctx, MovieCollectionShareService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionShareServiceClient) Update(ctx context.Context, in *UpdateMovieCollectionShareRequest, opts ...grpc.CallOption) (*MovieCollectionShare, error) {
	out := new(MovieCollectionShare)
	err := c.cc.Invoke(ctx, MovieCollectionShareService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionShareServiceClient) Delete(ctx context.Context, in *DeleteMovieCollectionShareRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, MovieCollectionShareService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionShareServiceClient) List(ctx context.Context, in *ListMovieCollectionShareRequest, opts ...grpc.CallOption) (*ListMovieCollectionShareResponse, error) {
	out := new(ListMovieCollectionShareResponse)
	err := c.cc.Invoke(ctx, MovieCollectionShareService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *movieCollectionShareServiceClient) BatchCreate(ctx context.Context, in *BatchCreateMovieCollectionSharesRequest, opts ...grpc.CallOption) (*BatchCreateMovieCollectionSharesResponse, error) {
	out := new(BatchCreateMovieCollectionSharesResponse)
	err := c.cc.Invoke(ctx, MovieCollectionShareService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MovieCollectionShareServiceServer is the server API for MovieCollectionShareService service.
// All implementations must embed UnimplementedMovieCollectionShareServiceServer
// for forward compatibility
type MovieCollectionShareServiceServer interface {
	Create(context.Context, *CreateMovieCollectionShareRequest) (*MovieCollectionShare, error)
	Get(context.Context, *GetMovieCollectionShareRequest) (*MovieCollectionShare, error)
	Update(context.Context, *UpdateMovieCollectionShareRequest) (*MovieCollectionShare, error)
	Delete(context.Context, *DeleteMovieCollectionShareRequest) (*empty.Empty, error)
	List(context.Context, *ListMovieCollectionShareRequest) (*ListMovieCollectionShareResponse, error)
	BatchCreate(context.Context, *BatchCreateMovieCollectionSharesRequest) (*BatchCreateMovieCollectionSharesResponse, error)
	mustEmbedUnimplementedMovieCollectionShareServiceServer()
}

// UnimplementedMovieCollectionShareServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMovieCollectionShareServiceServer struct {
}

func (UnimplementedMovieCollectionShareServiceServer) Create(context.Context, *CreateMovieCollectionShareRequest) (*MovieCollectionShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedMovieCollectionShareServiceServer) Get(context.Context, *GetMovieCollectionShareRequest) (*MovieCollectionShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMovieCollectionShareServiceServer) Update(context.Context, *UpdateMovieCollectionShareRequest) (*MovieCollectionShare, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedMovieCollectionShareServiceServer) Delete(context.Context, *DeleteMovieCollectionShareRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMovieCollectionShareServiceServer) List(context.Context, *ListMovieCollectionShareRequest) (*ListMovieCollectionShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMovieCollectionShareServiceServer) BatchCreate(context.Context, *BatchCreateMovieCollectionSharesRequest) (*BatchCreateMovieCollectionSharesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedMovieCollectionShareServiceServer) mustEmbedUnimplementedMovieCollectionShareServiceServer() {
}

// UnsafeMovieCollectionShareServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MovieCollectionShareServiceServer will
// result in compilation errors.
type UnsafeMovieCollectionShareServiceServer interface {
	mustEmbedUnimplementedMovieCollectionShareServiceServer()
}

func RegisterMovieCollectionShareServiceServer(s grpc.ServiceRegistrar, srv MovieCollectionShareServiceServer) {
	s.RegisterService(&MovieCollectionShareService_ServiceDesc, srv)
}

func _MovieCollectionShareService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMovieCollectionShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionShareServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionShareService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionShareServiceServer).Create(ctx, req.(*CreateMovieCollectionShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionShareService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMovieCollectionShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionShareServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionShareService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionShareServiceServer).Get(ctx, req.(*GetMovieCollectionShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionShareService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMovieCollectionShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionShareServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionShareService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionShareServiceServer).Update(ctx, req.(*UpdateMovieCollectionShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionShareService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMovieCollectionShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionShareServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionShareService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionShareServiceServer).Delete(ctx, req.(*DeleteMovieCollectionShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionShareService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMovieCollectionShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionShareServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionShareService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionShareServiceServer).List(ctx, req.(*ListMovieCollectionShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MovieCollectionShareService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateMovieCollectionSharesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MovieCollectionShareServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MovieCollectionShareService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MovieCollectionShareServiceServer).BatchCreate(ctx, req.(*BatchCreateMovieCollectionSharesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MovieCollectionShareService_ServiceDesc is the grpc.ServiceDesc for MovieCollectionShareService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MovieCollectionShareService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.MovieCollectionShareService",
	HandlerType: (*MovieCollectionShareServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _MovieCollectionShareService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MovieCollectionShareService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _MovieCollectionShareService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MovieCollectionShareService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MovieCollectionShareService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _MovieCollectionShareService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}

const (
	UserService_Create_FullMethodName      = "/entpb.UserService/Create"
	UserService_Get_FullMethodName         = "/entpb.UserService/Get"
	UserService_Update_FullMethodName      = "/entpb.UserService/Update"
	UserService_Delete_FullMethodName      = "/entpb.UserService/Delete"
	UserService_List_FullMethodName        = "/entpb.UserService/List"
	UserService_BatchCreate_FullMethodName = "/entpb.UserService/BatchCreate"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	Create(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error)
	Get(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error)
	Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error)
	Delete(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListUserRequest, opts ...grpc.CallOption) (*ListUserResponse, error)
	BatchCreate(ctx context.Context, in *BatchCreateUsersRequest, opts ...grpc.CallOption) (*BatchCreateUsersResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Create(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Get(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Delete(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, UserService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) List(ctx context.Context, in *ListUserRequest, opts ...grpc.CallOption) (*ListUserResponse, error) {
	out := new(ListUserResponse)
	err := c.cc.Invoke(ctx, UserService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) BatchCreate(ctx context.Context, in *BatchCreateUsersRequest, opts ...grpc.CallOption) (*BatchCreateUsersResponse, error) {
	out := new(BatchCreateUsersResponse)
	err := c.cc.Invoke(ctx, UserService_BatchCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	Create(context.Context, *CreateUserRequest) (*User, error)
	Get(context.Context, *GetUserRequest) (*User, error)
	Update(context.Context, *UpdateUserRequest) (*User, error)
	Delete(context.Context, *DeleteUserRequest) (*empty.Empty, error)
	List(context.Context, *ListUserRequest) (*ListUserResponse, error)
	BatchCreate(context.Context, *BatchCreateUsersRequest) (*BatchCreateUsersResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) Create(context.Context, *CreateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedUserServiceServer) Get(context.Context, *GetUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedUserServiceServer) Update(context.Context, *UpdateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedUserServiceServer) Delete(context.Context, *DeleteUserRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedUserServiceServer) List(context.Context, *ListUserRequest) (*ListUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedUserServiceServer) BatchCreate(context.Context, *BatchCreateUsersRequest) (*BatchCreateUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreate not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Create(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Get(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Update(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Delete(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).List(ctx, req.(*ListUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_BatchCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).BatchCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_BatchCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).BatchCreate(ctx, req.(*BatchCreateUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "entpb.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _UserService_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UserService_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UserService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _UserService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _UserService_List_Handler,
		},
		{
			MethodName: "BatchCreate",
			Handler:    _UserService_BatchCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entpb/entpb.proto",
}
