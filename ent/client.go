// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/PaluMacil/dan2/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/PaluMacil/dan2/ent/amazonlist"
	"github.com/PaluMacil/dan2/ent/amazonorder"
	"github.com/PaluMacil/dan2/ent/amazonshare"
	"github.com/PaluMacil/dan2/ent/drink"
	"github.com/PaluMacil/dan2/ent/grocerylist"
	"github.com/PaluMacil/dan2/ent/grocerylistitem"
	"github.com/PaluMacil/dan2/ent/grocerylistshare"
	"github.com/PaluMacil/dan2/ent/movie"
	"github.com/PaluMacil/dan2/ent/moviecollection"
	"github.com/PaluMacil/dan2/ent/moviecollectionshare"
	"github.com/PaluMacil/dan2/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AmazonList is the client for interacting with the AmazonList builders.
	AmazonList *AmazonListClient
	// AmazonOrder is the client for interacting with the AmazonOrder builders.
	AmazonOrder *AmazonOrderClient
	// AmazonShare is the client for interacting with the AmazonShare builders.
	AmazonShare *AmazonShareClient
	// Drink is the client for interacting with the Drink builders.
	Drink *DrinkClient
	// GroceryList is the client for interacting with the GroceryList builders.
	GroceryList *GroceryListClient
	// GroceryListItem is the client for interacting with the GroceryListItem builders.
	GroceryListItem *GroceryListItemClient
	// GroceryListShare is the client for interacting with the GroceryListShare builders.
	GroceryListShare *GroceryListShareClient
	// Movie is the client for interacting with the Movie builders.
	Movie *MovieClient
	// MovieCollection is the client for interacting with the MovieCollection builders.
	MovieCollection *MovieCollectionClient
	// MovieCollectionShare is the client for interacting with the MovieCollectionShare builders.
	MovieCollectionShare *MovieCollectionShareClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AmazonList = NewAmazonListClient(c.config)
	c.AmazonOrder = NewAmazonOrderClient(c.config)
	c.AmazonShare = NewAmazonShareClient(c.config)
	c.Drink = NewDrinkClient(c.config)
	c.GroceryList = NewGroceryListClient(c.config)
	c.GroceryListItem = NewGroceryListItemClient(c.config)
	c.GroceryListShare = NewGroceryListShareClient(c.config)
	c.Movie = NewMovieClient(c.config)
	c.MovieCollection = NewMovieCollectionClient(c.config)
	c.MovieCollectionShare = NewMovieCollectionShareClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		AmazonList:           NewAmazonListClient(cfg),
		AmazonOrder:          NewAmazonOrderClient(cfg),
		AmazonShare:          NewAmazonShareClient(cfg),
		Drink:                NewDrinkClient(cfg),
		GroceryList:          NewGroceryListClient(cfg),
		GroceryListItem:      NewGroceryListItemClient(cfg),
		GroceryListShare:     NewGroceryListShareClient(cfg),
		Movie:                NewMovieClient(cfg),
		MovieCollection:      NewMovieCollectionClient(cfg),
		MovieCollectionShare: NewMovieCollectionShareClient(cfg),
		User:                 NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		AmazonList:           NewAmazonListClient(cfg),
		AmazonOrder:          NewAmazonOrderClient(cfg),
		AmazonShare:          NewAmazonShareClient(cfg),
		Drink:                NewDrinkClient(cfg),
		GroceryList:          NewGroceryListClient(cfg),
		GroceryListItem:      NewGroceryListItemClient(cfg),
		GroceryListShare:     NewGroceryListShareClient(cfg),
		Movie:                NewMovieClient(cfg),
		MovieCollection:      NewMovieCollectionClient(cfg),
		MovieCollectionShare: NewMovieCollectionShareClient(cfg),
		User:                 NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AmazonList.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AmazonList, c.AmazonOrder, c.AmazonShare, c.Drink, c.GroceryList,
		c.GroceryListItem, c.GroceryListShare, c.Movie, c.MovieCollection,
		c.MovieCollectionShare, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AmazonList, c.AmazonOrder, c.AmazonShare, c.Drink, c.GroceryList,
		c.GroceryListItem, c.GroceryListShare, c.Movie, c.MovieCollection,
		c.MovieCollectionShare, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AmazonListMutation:
		return c.AmazonList.mutate(ctx, m)
	case *AmazonOrderMutation:
		return c.AmazonOrder.mutate(ctx, m)
	case *AmazonShareMutation:
		return c.AmazonShare.mutate(ctx, m)
	case *DrinkMutation:
		return c.Drink.mutate(ctx, m)
	case *GroceryListMutation:
		return c.GroceryList.mutate(ctx, m)
	case *GroceryListItemMutation:
		return c.GroceryListItem.mutate(ctx, m)
	case *GroceryListShareMutation:
		return c.GroceryListShare.mutate(ctx, m)
	case *MovieMutation:
		return c.Movie.mutate(ctx, m)
	case *MovieCollectionMutation:
		return c.MovieCollection.mutate(ctx, m)
	case *MovieCollectionShareMutation:
		return c.MovieCollectionShare.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AmazonListClient is a client for the AmazonList schema.
type AmazonListClient struct {
	config
}

// NewAmazonListClient returns a client for the AmazonList from the given config.
func NewAmazonListClient(c config) *AmazonListClient {
	return &AmazonListClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `amazonlist.Hooks(f(g(h())))`.
func (c *AmazonListClient) Use(hooks ...Hook) {
	c.hooks.AmazonList = append(c.hooks.AmazonList, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `amazonlist.Intercept(f(g(h())))`.
func (c *AmazonListClient) Intercept(interceptors ...Interceptor) {
	c.inters.AmazonList = append(c.inters.AmazonList, interceptors...)
}

// Create returns a builder for creating a AmazonList entity.
func (c *AmazonListClient) Create() *AmazonListCreate {
	mutation := newAmazonListMutation(c.config, OpCreate)
	return &AmazonListCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AmazonList entities.
func (c *AmazonListClient) CreateBulk(builders ...*AmazonListCreate) *AmazonListCreateBulk {
	return &AmazonListCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AmazonList.
func (c *AmazonListClient) Update() *AmazonListUpdate {
	mutation := newAmazonListMutation(c.config, OpUpdate)
	return &AmazonListUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AmazonListClient) UpdateOne(al *AmazonList) *AmazonListUpdateOne {
	mutation := newAmazonListMutation(c.config, OpUpdateOne, withAmazonList(al))
	return &AmazonListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AmazonListClient) UpdateOneID(id int) *AmazonListUpdateOne {
	mutation := newAmazonListMutation(c.config, OpUpdateOne, withAmazonListID(id))
	return &AmazonListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AmazonList.
func (c *AmazonListClient) Delete() *AmazonListDelete {
	mutation := newAmazonListMutation(c.config, OpDelete)
	return &AmazonListDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AmazonListClient) DeleteOne(al *AmazonList) *AmazonListDeleteOne {
	return c.DeleteOneID(al.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AmazonListClient) DeleteOneID(id int) *AmazonListDeleteOne {
	builder := c.Delete().Where(amazonlist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AmazonListDeleteOne{builder}
}

// Query returns a query builder for AmazonList.
func (c *AmazonListClient) Query() *AmazonListQuery {
	return &AmazonListQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAmazonList},
		inters: c.Interceptors(),
	}
}

// Get returns a AmazonList entity by its id.
func (c *AmazonListClient) Get(ctx context.Context, id int) (*AmazonList, error) {
	return c.Query().Where(amazonlist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AmazonListClient) GetX(ctx context.Context, id int) *AmazonList {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAmazonOrders queries the amazon_orders edge of a AmazonList.
func (c *AmazonListClient) QueryAmazonOrders(al *AmazonList) *AmazonOrderQuery {
	query := (&AmazonOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := al.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amazonlist.Table, amazonlist.FieldID, id),
			sqlgraph.To(amazonorder.Table, amazonorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, amazonlist.AmazonOrdersTable, amazonlist.AmazonOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(al.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a AmazonList.
func (c *AmazonListClient) QueryOwner(al *AmazonList) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := al.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amazonlist.Table, amazonlist.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, amazonlist.OwnerTable, amazonlist.OwnerPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(al.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAmazonShares queries the amazon_shares edge of a AmazonList.
func (c *AmazonListClient) QueryAmazonShares(al *AmazonList) *AmazonShareQuery {
	query := (&AmazonShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := al.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amazonlist.Table, amazonlist.FieldID, id),
			sqlgraph.To(amazonshare.Table, amazonshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, amazonlist.AmazonSharesTable, amazonlist.AmazonSharesColumn),
		)
		fromV = sqlgraph.Neighbors(al.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AmazonListClient) Hooks() []Hook {
	return c.hooks.AmazonList
}

// Interceptors returns the client interceptors.
func (c *AmazonListClient) Interceptors() []Interceptor {
	return c.inters.AmazonList
}

func (c *AmazonListClient) mutate(ctx context.Context, m *AmazonListMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AmazonListCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AmazonListUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AmazonListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AmazonListDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AmazonList mutation op: %q", m.Op())
	}
}

// AmazonOrderClient is a client for the AmazonOrder schema.
type AmazonOrderClient struct {
	config
}

// NewAmazonOrderClient returns a client for the AmazonOrder from the given config.
func NewAmazonOrderClient(c config) *AmazonOrderClient {
	return &AmazonOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `amazonorder.Hooks(f(g(h())))`.
func (c *AmazonOrderClient) Use(hooks ...Hook) {
	c.hooks.AmazonOrder = append(c.hooks.AmazonOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `amazonorder.Intercept(f(g(h())))`.
func (c *AmazonOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.AmazonOrder = append(c.inters.AmazonOrder, interceptors...)
}

// Create returns a builder for creating a AmazonOrder entity.
func (c *AmazonOrderClient) Create() *AmazonOrderCreate {
	mutation := newAmazonOrderMutation(c.config, OpCreate)
	return &AmazonOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AmazonOrder entities.
func (c *AmazonOrderClient) CreateBulk(builders ...*AmazonOrderCreate) *AmazonOrderCreateBulk {
	return &AmazonOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AmazonOrder.
func (c *AmazonOrderClient) Update() *AmazonOrderUpdate {
	mutation := newAmazonOrderMutation(c.config, OpUpdate)
	return &AmazonOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AmazonOrderClient) UpdateOne(ao *AmazonOrder) *AmazonOrderUpdateOne {
	mutation := newAmazonOrderMutation(c.config, OpUpdateOne, withAmazonOrder(ao))
	return &AmazonOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AmazonOrderClient) UpdateOneID(id int) *AmazonOrderUpdateOne {
	mutation := newAmazonOrderMutation(c.config, OpUpdateOne, withAmazonOrderID(id))
	return &AmazonOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AmazonOrder.
func (c *AmazonOrderClient) Delete() *AmazonOrderDelete {
	mutation := newAmazonOrderMutation(c.config, OpDelete)
	return &AmazonOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AmazonOrderClient) DeleteOne(ao *AmazonOrder) *AmazonOrderDeleteOne {
	return c.DeleteOneID(ao.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AmazonOrderClient) DeleteOneID(id int) *AmazonOrderDeleteOne {
	builder := c.Delete().Where(amazonorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AmazonOrderDeleteOne{builder}
}

// Query returns a query builder for AmazonOrder.
func (c *AmazonOrderClient) Query() *AmazonOrderQuery {
	return &AmazonOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAmazonOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a AmazonOrder entity by its id.
func (c *AmazonOrderClient) Get(ctx context.Context, id int) (*AmazonOrder, error) {
	return c.Query().Where(amazonorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AmazonOrderClient) GetX(ctx context.Context, id int) *AmazonOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAmazonList queries the amazon_list edge of a AmazonOrder.
func (c *AmazonOrderClient) QueryAmazonList(ao *AmazonOrder) *AmazonListQuery {
	query := (&AmazonListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ao.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amazonorder.Table, amazonorder.FieldID, id),
			sqlgraph.To(amazonlist.Table, amazonlist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, amazonorder.AmazonListTable, amazonorder.AmazonListColumn),
		)
		fromV = sqlgraph.Neighbors(ao.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AmazonOrderClient) Hooks() []Hook {
	return c.hooks.AmazonOrder
}

// Interceptors returns the client interceptors.
func (c *AmazonOrderClient) Interceptors() []Interceptor {
	return c.inters.AmazonOrder
}

func (c *AmazonOrderClient) mutate(ctx context.Context, m *AmazonOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AmazonOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AmazonOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AmazonOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AmazonOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AmazonOrder mutation op: %q", m.Op())
	}
}

// AmazonShareClient is a client for the AmazonShare schema.
type AmazonShareClient struct {
	config
}

// NewAmazonShareClient returns a client for the AmazonShare from the given config.
func NewAmazonShareClient(c config) *AmazonShareClient {
	return &AmazonShareClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `amazonshare.Hooks(f(g(h())))`.
func (c *AmazonShareClient) Use(hooks ...Hook) {
	c.hooks.AmazonShare = append(c.hooks.AmazonShare, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `amazonshare.Intercept(f(g(h())))`.
func (c *AmazonShareClient) Intercept(interceptors ...Interceptor) {
	c.inters.AmazonShare = append(c.inters.AmazonShare, interceptors...)
}

// Create returns a builder for creating a AmazonShare entity.
func (c *AmazonShareClient) Create() *AmazonShareCreate {
	mutation := newAmazonShareMutation(c.config, OpCreate)
	return &AmazonShareCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AmazonShare entities.
func (c *AmazonShareClient) CreateBulk(builders ...*AmazonShareCreate) *AmazonShareCreateBulk {
	return &AmazonShareCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AmazonShare.
func (c *AmazonShareClient) Update() *AmazonShareUpdate {
	mutation := newAmazonShareMutation(c.config, OpUpdate)
	return &AmazonShareUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AmazonShareClient) UpdateOne(as *AmazonShare) *AmazonShareUpdateOne {
	mutation := newAmazonShareMutation(c.config, OpUpdateOne, withAmazonShare(as))
	return &AmazonShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AmazonShareClient) UpdateOneID(id int) *AmazonShareUpdateOne {
	mutation := newAmazonShareMutation(c.config, OpUpdateOne, withAmazonShareID(id))
	return &AmazonShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AmazonShare.
func (c *AmazonShareClient) Delete() *AmazonShareDelete {
	mutation := newAmazonShareMutation(c.config, OpDelete)
	return &AmazonShareDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AmazonShareClient) DeleteOne(as *AmazonShare) *AmazonShareDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AmazonShareClient) DeleteOneID(id int) *AmazonShareDeleteOne {
	builder := c.Delete().Where(amazonshare.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AmazonShareDeleteOne{builder}
}

// Query returns a query builder for AmazonShare.
func (c *AmazonShareClient) Query() *AmazonShareQuery {
	return &AmazonShareQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAmazonShare},
		inters: c.Interceptors(),
	}
}

// Get returns a AmazonShare entity by its id.
func (c *AmazonShareClient) Get(ctx context.Context, id int) (*AmazonShare, error) {
	return c.Query().Where(amazonshare.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AmazonShareClient) GetX(ctx context.Context, id int) *AmazonShare {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a AmazonShare.
func (c *AmazonShareClient) QueryUser(as *AmazonShare) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amazonshare.Table, amazonshare.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, amazonshare.UserTable, amazonshare.UserColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAmazonList queries the amazon_list edge of a AmazonShare.
func (c *AmazonShareClient) QueryAmazonList(as *AmazonShare) *AmazonListQuery {
	query := (&AmazonListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(amazonshare.Table, amazonshare.FieldID, id),
			sqlgraph.To(amazonlist.Table, amazonlist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, amazonshare.AmazonListTable, amazonshare.AmazonListColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AmazonShareClient) Hooks() []Hook {
	return c.hooks.AmazonShare
}

// Interceptors returns the client interceptors.
func (c *AmazonShareClient) Interceptors() []Interceptor {
	return c.inters.AmazonShare
}

func (c *AmazonShareClient) mutate(ctx context.Context, m *AmazonShareMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AmazonShareCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AmazonShareUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AmazonShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AmazonShareDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AmazonShare mutation op: %q", m.Op())
	}
}

// DrinkClient is a client for the Drink schema.
type DrinkClient struct {
	config
}

// NewDrinkClient returns a client for the Drink from the given config.
func NewDrinkClient(c config) *DrinkClient {
	return &DrinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `drink.Hooks(f(g(h())))`.
func (c *DrinkClient) Use(hooks ...Hook) {
	c.hooks.Drink = append(c.hooks.Drink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `drink.Intercept(f(g(h())))`.
func (c *DrinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.Drink = append(c.inters.Drink, interceptors...)
}

// Create returns a builder for creating a Drink entity.
func (c *DrinkClient) Create() *DrinkCreate {
	mutation := newDrinkMutation(c.config, OpCreate)
	return &DrinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Drink entities.
func (c *DrinkClient) CreateBulk(builders ...*DrinkCreate) *DrinkCreateBulk {
	return &DrinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Drink.
func (c *DrinkClient) Update() *DrinkUpdate {
	mutation := newDrinkMutation(c.config, OpUpdate)
	return &DrinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DrinkClient) UpdateOne(d *Drink) *DrinkUpdateOne {
	mutation := newDrinkMutation(c.config, OpUpdateOne, withDrink(d))
	return &DrinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DrinkClient) UpdateOneID(id int) *DrinkUpdateOne {
	mutation := newDrinkMutation(c.config, OpUpdateOne, withDrinkID(id))
	return &DrinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Drink.
func (c *DrinkClient) Delete() *DrinkDelete {
	mutation := newDrinkMutation(c.config, OpDelete)
	return &DrinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DrinkClient) DeleteOne(d *Drink) *DrinkDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DrinkClient) DeleteOneID(id int) *DrinkDeleteOne {
	builder := c.Delete().Where(drink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DrinkDeleteOne{builder}
}

// Query returns a query builder for Drink.
func (c *DrinkClient) Query() *DrinkQuery {
	return &DrinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDrink},
		inters: c.Interceptors(),
	}
}

// Get returns a Drink entity by its id.
func (c *DrinkClient) Get(ctx context.Context, id int) (*Drink, error) {
	return c.Query().Where(drink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DrinkClient) GetX(ctx context.Context, id int) *Drink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Drink.
func (c *DrinkClient) QueryOwner(d *Drink) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(drink.Table, drink.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, drink.OwnerTable, drink.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DrinkClient) Hooks() []Hook {
	return c.hooks.Drink
}

// Interceptors returns the client interceptors.
func (c *DrinkClient) Interceptors() []Interceptor {
	return c.inters.Drink
}

func (c *DrinkClient) mutate(ctx context.Context, m *DrinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DrinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DrinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DrinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DrinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Drink mutation op: %q", m.Op())
	}
}

// GroceryListClient is a client for the GroceryList schema.
type GroceryListClient struct {
	config
}

// NewGroceryListClient returns a client for the GroceryList from the given config.
func NewGroceryListClient(c config) *GroceryListClient {
	return &GroceryListClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grocerylist.Hooks(f(g(h())))`.
func (c *GroceryListClient) Use(hooks ...Hook) {
	c.hooks.GroceryList = append(c.hooks.GroceryList, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grocerylist.Intercept(f(g(h())))`.
func (c *GroceryListClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroceryList = append(c.inters.GroceryList, interceptors...)
}

// Create returns a builder for creating a GroceryList entity.
func (c *GroceryListClient) Create() *GroceryListCreate {
	mutation := newGroceryListMutation(c.config, OpCreate)
	return &GroceryListCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroceryList entities.
func (c *GroceryListClient) CreateBulk(builders ...*GroceryListCreate) *GroceryListCreateBulk {
	return &GroceryListCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroceryList.
func (c *GroceryListClient) Update() *GroceryListUpdate {
	mutation := newGroceryListMutation(c.config, OpUpdate)
	return &GroceryListUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroceryListClient) UpdateOne(gl *GroceryList) *GroceryListUpdateOne {
	mutation := newGroceryListMutation(c.config, OpUpdateOne, withGroceryList(gl))
	return &GroceryListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroceryListClient) UpdateOneID(id int) *GroceryListUpdateOne {
	mutation := newGroceryListMutation(c.config, OpUpdateOne, withGroceryListID(id))
	return &GroceryListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroceryList.
func (c *GroceryListClient) Delete() *GroceryListDelete {
	mutation := newGroceryListMutation(c.config, OpDelete)
	return &GroceryListDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroceryListClient) DeleteOne(gl *GroceryList) *GroceryListDeleteOne {
	return c.DeleteOneID(gl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroceryListClient) DeleteOneID(id int) *GroceryListDeleteOne {
	builder := c.Delete().Where(grocerylist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroceryListDeleteOne{builder}
}

// Query returns a query builder for GroceryList.
func (c *GroceryListClient) Query() *GroceryListQuery {
	return &GroceryListQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroceryList},
		inters: c.Interceptors(),
	}
}

// Get returns a GroceryList entity by its id.
func (c *GroceryListClient) Get(ctx context.Context, id int) (*GroceryList, error) {
	return c.Query().Where(grocerylist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroceryListClient) GetX(ctx context.Context, id int) *GroceryList {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroceryListItems queries the grocery_list_items edge of a GroceryList.
func (c *GroceryListClient) QueryGroceryListItems(gl *GroceryList) *GroceryListItemQuery {
	query := (&GroceryListItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grocerylist.Table, grocerylist.FieldID, id),
			sqlgraph.To(grocerylistitem.Table, grocerylistitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, grocerylist.GroceryListItemsTable, grocerylist.GroceryListItemsColumn),
		)
		fromV = sqlgraph.Neighbors(gl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a GroceryList.
func (c *GroceryListClient) QueryOwner(gl *GroceryList) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grocerylist.Table, grocerylist.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grocerylist.OwnerTable, grocerylist.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(gl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroceryListShares queries the grocery_list_shares edge of a GroceryList.
func (c *GroceryListClient) QueryGroceryListShares(gl *GroceryList) *GroceryListShareQuery {
	query := (&GroceryListShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grocerylist.Table, grocerylist.FieldID, id),
			sqlgraph.To(grocerylistshare.Table, grocerylistshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, grocerylist.GroceryListSharesTable, grocerylist.GroceryListSharesColumn),
		)
		fromV = sqlgraph.Neighbors(gl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroceryListClient) Hooks() []Hook {
	return c.hooks.GroceryList
}

// Interceptors returns the client interceptors.
func (c *GroceryListClient) Interceptors() []Interceptor {
	return c.inters.GroceryList
}

func (c *GroceryListClient) mutate(ctx context.Context, m *GroceryListMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroceryListCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroceryListUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroceryListUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroceryListDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GroceryList mutation op: %q", m.Op())
	}
}

// GroceryListItemClient is a client for the GroceryListItem schema.
type GroceryListItemClient struct {
	config
}

// NewGroceryListItemClient returns a client for the GroceryListItem from the given config.
func NewGroceryListItemClient(c config) *GroceryListItemClient {
	return &GroceryListItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grocerylistitem.Hooks(f(g(h())))`.
func (c *GroceryListItemClient) Use(hooks ...Hook) {
	c.hooks.GroceryListItem = append(c.hooks.GroceryListItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grocerylistitem.Intercept(f(g(h())))`.
func (c *GroceryListItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroceryListItem = append(c.inters.GroceryListItem, interceptors...)
}

// Create returns a builder for creating a GroceryListItem entity.
func (c *GroceryListItemClient) Create() *GroceryListItemCreate {
	mutation := newGroceryListItemMutation(c.config, OpCreate)
	return &GroceryListItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroceryListItem entities.
func (c *GroceryListItemClient) CreateBulk(builders ...*GroceryListItemCreate) *GroceryListItemCreateBulk {
	return &GroceryListItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroceryListItem.
func (c *GroceryListItemClient) Update() *GroceryListItemUpdate {
	mutation := newGroceryListItemMutation(c.config, OpUpdate)
	return &GroceryListItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroceryListItemClient) UpdateOne(gli *GroceryListItem) *GroceryListItemUpdateOne {
	mutation := newGroceryListItemMutation(c.config, OpUpdateOne, withGroceryListItem(gli))
	return &GroceryListItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroceryListItemClient) UpdateOneID(id int) *GroceryListItemUpdateOne {
	mutation := newGroceryListItemMutation(c.config, OpUpdateOne, withGroceryListItemID(id))
	return &GroceryListItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroceryListItem.
func (c *GroceryListItemClient) Delete() *GroceryListItemDelete {
	mutation := newGroceryListItemMutation(c.config, OpDelete)
	return &GroceryListItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroceryListItemClient) DeleteOne(gli *GroceryListItem) *GroceryListItemDeleteOne {
	return c.DeleteOneID(gli.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroceryListItemClient) DeleteOneID(id int) *GroceryListItemDeleteOne {
	builder := c.Delete().Where(grocerylistitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroceryListItemDeleteOne{builder}
}

// Query returns a query builder for GroceryListItem.
func (c *GroceryListItemClient) Query() *GroceryListItemQuery {
	return &GroceryListItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroceryListItem},
		inters: c.Interceptors(),
	}
}

// Get returns a GroceryListItem entity by its id.
func (c *GroceryListItemClient) Get(ctx context.Context, id int) (*GroceryListItem, error) {
	return c.Query().Where(grocerylistitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroceryListItemClient) GetX(ctx context.Context, id int) *GroceryListItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroceryList queries the grocery_list edge of a GroceryListItem.
func (c *GroceryListItemClient) QueryGroceryList(gli *GroceryListItem) *GroceryListQuery {
	query := (&GroceryListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gli.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grocerylistitem.Table, grocerylistitem.FieldID, id),
			sqlgraph.To(grocerylist.Table, grocerylist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grocerylistitem.GroceryListTable, grocerylistitem.GroceryListColumn),
		)
		fromV = sqlgraph.Neighbors(gli.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroceryListItemClient) Hooks() []Hook {
	return c.hooks.GroceryListItem
}

// Interceptors returns the client interceptors.
func (c *GroceryListItemClient) Interceptors() []Interceptor {
	return c.inters.GroceryListItem
}

func (c *GroceryListItemClient) mutate(ctx context.Context, m *GroceryListItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroceryListItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroceryListItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroceryListItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroceryListItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GroceryListItem mutation op: %q", m.Op())
	}
}

// GroceryListShareClient is a client for the GroceryListShare schema.
type GroceryListShareClient struct {
	config
}

// NewGroceryListShareClient returns a client for the GroceryListShare from the given config.
func NewGroceryListShareClient(c config) *GroceryListShareClient {
	return &GroceryListShareClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grocerylistshare.Hooks(f(g(h())))`.
func (c *GroceryListShareClient) Use(hooks ...Hook) {
	c.hooks.GroceryListShare = append(c.hooks.GroceryListShare, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grocerylistshare.Intercept(f(g(h())))`.
func (c *GroceryListShareClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroceryListShare = append(c.inters.GroceryListShare, interceptors...)
}

// Create returns a builder for creating a GroceryListShare entity.
func (c *GroceryListShareClient) Create() *GroceryListShareCreate {
	mutation := newGroceryListShareMutation(c.config, OpCreate)
	return &GroceryListShareCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroceryListShare entities.
func (c *GroceryListShareClient) CreateBulk(builders ...*GroceryListShareCreate) *GroceryListShareCreateBulk {
	return &GroceryListShareCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroceryListShare.
func (c *GroceryListShareClient) Update() *GroceryListShareUpdate {
	mutation := newGroceryListShareMutation(c.config, OpUpdate)
	return &GroceryListShareUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroceryListShareClient) UpdateOne(gls *GroceryListShare) *GroceryListShareUpdateOne {
	mutation := newGroceryListShareMutation(c.config, OpUpdateOne, withGroceryListShare(gls))
	return &GroceryListShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroceryListShareClient) UpdateOneID(id int) *GroceryListShareUpdateOne {
	mutation := newGroceryListShareMutation(c.config, OpUpdateOne, withGroceryListShareID(id))
	return &GroceryListShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroceryListShare.
func (c *GroceryListShareClient) Delete() *GroceryListShareDelete {
	mutation := newGroceryListShareMutation(c.config, OpDelete)
	return &GroceryListShareDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroceryListShareClient) DeleteOne(gls *GroceryListShare) *GroceryListShareDeleteOne {
	return c.DeleteOneID(gls.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroceryListShareClient) DeleteOneID(id int) *GroceryListShareDeleteOne {
	builder := c.Delete().Where(grocerylistshare.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroceryListShareDeleteOne{builder}
}

// Query returns a query builder for GroceryListShare.
func (c *GroceryListShareClient) Query() *GroceryListShareQuery {
	return &GroceryListShareQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroceryListShare},
		inters: c.Interceptors(),
	}
}

// Get returns a GroceryListShare entity by its id.
func (c *GroceryListShareClient) Get(ctx context.Context, id int) (*GroceryListShare, error) {
	return c.Query().Where(grocerylistshare.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroceryListShareClient) GetX(ctx context.Context, id int) *GroceryListShare {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a GroceryListShare.
func (c *GroceryListShareClient) QueryUser(gls *GroceryListShare) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gls.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grocerylistshare.Table, grocerylistshare.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grocerylistshare.UserTable, grocerylistshare.UserColumn),
		)
		fromV = sqlgraph.Neighbors(gls.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroceryList queries the grocery_list edge of a GroceryListShare.
func (c *GroceryListShareClient) QueryGroceryList(gls *GroceryListShare) *GroceryListQuery {
	query := (&GroceryListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gls.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grocerylistshare.Table, grocerylistshare.FieldID, id),
			sqlgraph.To(grocerylist.Table, grocerylist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grocerylistshare.GroceryListTable, grocerylistshare.GroceryListColumn),
		)
		fromV = sqlgraph.Neighbors(gls.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroceryListShareClient) Hooks() []Hook {
	return c.hooks.GroceryListShare
}

// Interceptors returns the client interceptors.
func (c *GroceryListShareClient) Interceptors() []Interceptor {
	return c.inters.GroceryListShare
}

func (c *GroceryListShareClient) mutate(ctx context.Context, m *GroceryListShareMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroceryListShareCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroceryListShareUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroceryListShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroceryListShareDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GroceryListShare mutation op: %q", m.Op())
	}
}

// MovieClient is a client for the Movie schema.
type MovieClient struct {
	config
}

// NewMovieClient returns a client for the Movie from the given config.
func NewMovieClient(c config) *MovieClient {
	return &MovieClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `movie.Hooks(f(g(h())))`.
func (c *MovieClient) Use(hooks ...Hook) {
	c.hooks.Movie = append(c.hooks.Movie, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `movie.Intercept(f(g(h())))`.
func (c *MovieClient) Intercept(interceptors ...Interceptor) {
	c.inters.Movie = append(c.inters.Movie, interceptors...)
}

// Create returns a builder for creating a Movie entity.
func (c *MovieClient) Create() *MovieCreate {
	mutation := newMovieMutation(c.config, OpCreate)
	return &MovieCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Movie entities.
func (c *MovieClient) CreateBulk(builders ...*MovieCreate) *MovieCreateBulk {
	return &MovieCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Movie.
func (c *MovieClient) Update() *MovieUpdate {
	mutation := newMovieMutation(c.config, OpUpdate)
	return &MovieUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MovieClient) UpdateOne(m *Movie) *MovieUpdateOne {
	mutation := newMovieMutation(c.config, OpUpdateOne, withMovie(m))
	return &MovieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MovieClient) UpdateOneID(id int) *MovieUpdateOne {
	mutation := newMovieMutation(c.config, OpUpdateOne, withMovieID(id))
	return &MovieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Movie.
func (c *MovieClient) Delete() *MovieDelete {
	mutation := newMovieMutation(c.config, OpDelete)
	return &MovieDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MovieClient) DeleteOne(m *Movie) *MovieDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MovieClient) DeleteOneID(id int) *MovieDeleteOne {
	builder := c.Delete().Where(movie.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MovieDeleteOne{builder}
}

// Query returns a query builder for Movie.
func (c *MovieClient) Query() *MovieQuery {
	return &MovieQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMovie},
		inters: c.Interceptors(),
	}
}

// Get returns a Movie entity by its id.
func (c *MovieClient) Get(ctx context.Context, id int) (*Movie, error) {
	return c.Query().Where(movie.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MovieClient) GetX(ctx context.Context, id int) *Movie {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMovieCollection queries the movie_collection edge of a Movie.
func (c *MovieClient) QueryMovieCollection(m *Movie) *MovieCollectionQuery {
	query := (&MovieCollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(movie.Table, movie.FieldID, id),
			sqlgraph.To(moviecollection.Table, moviecollection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, movie.MovieCollectionTable, movie.MovieCollectionColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MovieClient) Hooks() []Hook {
	return c.hooks.Movie
}

// Interceptors returns the client interceptors.
func (c *MovieClient) Interceptors() []Interceptor {
	return c.inters.Movie
}

func (c *MovieClient) mutate(ctx context.Context, m *MovieMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MovieCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MovieUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MovieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MovieDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Movie mutation op: %q", m.Op())
	}
}

// MovieCollectionClient is a client for the MovieCollection schema.
type MovieCollectionClient struct {
	config
}

// NewMovieCollectionClient returns a client for the MovieCollection from the given config.
func NewMovieCollectionClient(c config) *MovieCollectionClient {
	return &MovieCollectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `moviecollection.Hooks(f(g(h())))`.
func (c *MovieCollectionClient) Use(hooks ...Hook) {
	c.hooks.MovieCollection = append(c.hooks.MovieCollection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `moviecollection.Intercept(f(g(h())))`.
func (c *MovieCollectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MovieCollection = append(c.inters.MovieCollection, interceptors...)
}

// Create returns a builder for creating a MovieCollection entity.
func (c *MovieCollectionClient) Create() *MovieCollectionCreate {
	mutation := newMovieCollectionMutation(c.config, OpCreate)
	return &MovieCollectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MovieCollection entities.
func (c *MovieCollectionClient) CreateBulk(builders ...*MovieCollectionCreate) *MovieCollectionCreateBulk {
	return &MovieCollectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MovieCollection.
func (c *MovieCollectionClient) Update() *MovieCollectionUpdate {
	mutation := newMovieCollectionMutation(c.config, OpUpdate)
	return &MovieCollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MovieCollectionClient) UpdateOne(mc *MovieCollection) *MovieCollectionUpdateOne {
	mutation := newMovieCollectionMutation(c.config, OpUpdateOne, withMovieCollection(mc))
	return &MovieCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MovieCollectionClient) UpdateOneID(id int) *MovieCollectionUpdateOne {
	mutation := newMovieCollectionMutation(c.config, OpUpdateOne, withMovieCollectionID(id))
	return &MovieCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MovieCollection.
func (c *MovieCollectionClient) Delete() *MovieCollectionDelete {
	mutation := newMovieCollectionMutation(c.config, OpDelete)
	return &MovieCollectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MovieCollectionClient) DeleteOne(mc *MovieCollection) *MovieCollectionDeleteOne {
	return c.DeleteOneID(mc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MovieCollectionClient) DeleteOneID(id int) *MovieCollectionDeleteOne {
	builder := c.Delete().Where(moviecollection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MovieCollectionDeleteOne{builder}
}

// Query returns a query builder for MovieCollection.
func (c *MovieCollectionClient) Query() *MovieCollectionQuery {
	return &MovieCollectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMovieCollection},
		inters: c.Interceptors(),
	}
}

// Get returns a MovieCollection entity by its id.
func (c *MovieCollectionClient) Get(ctx context.Context, id int) (*MovieCollection, error) {
	return c.Query().Where(moviecollection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MovieCollectionClient) GetX(ctx context.Context, id int) *MovieCollection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMovies queries the movies edge of a MovieCollection.
func (c *MovieCollectionClient) QueryMovies(mc *MovieCollection) *MovieQuery {
	query := (&MovieClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moviecollection.Table, moviecollection.FieldID, id),
			sqlgraph.To(movie.Table, movie.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, moviecollection.MoviesTable, moviecollection.MoviesColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a MovieCollection.
func (c *MovieCollectionClient) QueryOwner(mc *MovieCollection) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moviecollection.Table, moviecollection.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, moviecollection.OwnerTable, moviecollection.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMovieCollectionShares queries the movie_collection_shares edge of a MovieCollection.
func (c *MovieCollectionClient) QueryMovieCollectionShares(mc *MovieCollection) *MovieCollectionShareQuery {
	query := (&MovieCollectionShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moviecollection.Table, moviecollection.FieldID, id),
			sqlgraph.To(moviecollectionshare.Table, moviecollectionshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, moviecollection.MovieCollectionSharesTable, moviecollection.MovieCollectionSharesColumn),
		)
		fromV = sqlgraph.Neighbors(mc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MovieCollectionClient) Hooks() []Hook {
	return c.hooks.MovieCollection
}

// Interceptors returns the client interceptors.
func (c *MovieCollectionClient) Interceptors() []Interceptor {
	return c.inters.MovieCollection
}

func (c *MovieCollectionClient) mutate(ctx context.Context, m *MovieCollectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MovieCollectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MovieCollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MovieCollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MovieCollectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MovieCollection mutation op: %q", m.Op())
	}
}

// MovieCollectionShareClient is a client for the MovieCollectionShare schema.
type MovieCollectionShareClient struct {
	config
}

// NewMovieCollectionShareClient returns a client for the MovieCollectionShare from the given config.
func NewMovieCollectionShareClient(c config) *MovieCollectionShareClient {
	return &MovieCollectionShareClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `moviecollectionshare.Hooks(f(g(h())))`.
func (c *MovieCollectionShareClient) Use(hooks ...Hook) {
	c.hooks.MovieCollectionShare = append(c.hooks.MovieCollectionShare, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `moviecollectionshare.Intercept(f(g(h())))`.
func (c *MovieCollectionShareClient) Intercept(interceptors ...Interceptor) {
	c.inters.MovieCollectionShare = append(c.inters.MovieCollectionShare, interceptors...)
}

// Create returns a builder for creating a MovieCollectionShare entity.
func (c *MovieCollectionShareClient) Create() *MovieCollectionShareCreate {
	mutation := newMovieCollectionShareMutation(c.config, OpCreate)
	return &MovieCollectionShareCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MovieCollectionShare entities.
func (c *MovieCollectionShareClient) CreateBulk(builders ...*MovieCollectionShareCreate) *MovieCollectionShareCreateBulk {
	return &MovieCollectionShareCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MovieCollectionShare.
func (c *MovieCollectionShareClient) Update() *MovieCollectionShareUpdate {
	mutation := newMovieCollectionShareMutation(c.config, OpUpdate)
	return &MovieCollectionShareUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MovieCollectionShareClient) UpdateOne(mcs *MovieCollectionShare) *MovieCollectionShareUpdateOne {
	mutation := newMovieCollectionShareMutation(c.config, OpUpdateOne, withMovieCollectionShare(mcs))
	return &MovieCollectionShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MovieCollectionShareClient) UpdateOneID(id int) *MovieCollectionShareUpdateOne {
	mutation := newMovieCollectionShareMutation(c.config, OpUpdateOne, withMovieCollectionShareID(id))
	return &MovieCollectionShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MovieCollectionShare.
func (c *MovieCollectionShareClient) Delete() *MovieCollectionShareDelete {
	mutation := newMovieCollectionShareMutation(c.config, OpDelete)
	return &MovieCollectionShareDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MovieCollectionShareClient) DeleteOne(mcs *MovieCollectionShare) *MovieCollectionShareDeleteOne {
	return c.DeleteOneID(mcs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MovieCollectionShareClient) DeleteOneID(id int) *MovieCollectionShareDeleteOne {
	builder := c.Delete().Where(moviecollectionshare.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MovieCollectionShareDeleteOne{builder}
}

// Query returns a query builder for MovieCollectionShare.
func (c *MovieCollectionShareClient) Query() *MovieCollectionShareQuery {
	return &MovieCollectionShareQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMovieCollectionShare},
		inters: c.Interceptors(),
	}
}

// Get returns a MovieCollectionShare entity by its id.
func (c *MovieCollectionShareClient) Get(ctx context.Context, id int) (*MovieCollectionShare, error) {
	return c.Query().Where(moviecollectionshare.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MovieCollectionShareClient) GetX(ctx context.Context, id int) *MovieCollectionShare {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MovieCollectionShare.
func (c *MovieCollectionShareClient) QueryUser(mcs *MovieCollectionShare) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mcs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moviecollectionshare.Table, moviecollectionshare.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, moviecollectionshare.UserTable, moviecollectionshare.UserColumn),
		)
		fromV = sqlgraph.Neighbors(mcs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMovieCollection queries the movie_collection edge of a MovieCollectionShare.
func (c *MovieCollectionShareClient) QueryMovieCollection(mcs *MovieCollectionShare) *MovieCollectionQuery {
	query := (&MovieCollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mcs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(moviecollectionshare.Table, moviecollectionshare.FieldID, id),
			sqlgraph.To(moviecollection.Table, moviecollection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, moviecollectionshare.MovieCollectionTable, moviecollectionshare.MovieCollectionColumn),
		)
		fromV = sqlgraph.Neighbors(mcs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MovieCollectionShareClient) Hooks() []Hook {
	return c.hooks.MovieCollectionShare
}

// Interceptors returns the client interceptors.
func (c *MovieCollectionShareClient) Interceptors() []Interceptor {
	return c.inters.MovieCollectionShare
}

func (c *MovieCollectionShareClient) mutate(ctx context.Context, m *MovieCollectionShareMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MovieCollectionShareCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MovieCollectionShareUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MovieCollectionShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MovieCollectionShareDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MovieCollectionShare mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAmazonShares queries the amazon_shares edge of a User.
func (c *UserClient) QueryAmazonShares(u *User) *AmazonShareQuery {
	query := (&AmazonShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(amazonshare.Table, amazonshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AmazonSharesTable, user.AmazonSharesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAmazonLists queries the amazon_lists edge of a User.
func (c *UserClient) QueryAmazonLists(u *User) *AmazonListQuery {
	query := (&AmazonListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(amazonlist.Table, amazonlist.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.AmazonListsTable, user.AmazonListsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDrinks queries the drinks edge of a User.
func (c *UserClient) QueryDrinks(u *User) *DrinkQuery {
	query := (&DrinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(drink.Table, drink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DrinksTable, user.DrinksColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroceryLists queries the grocery_lists edge of a User.
func (c *UserClient) QueryGroceryLists(u *User) *GroceryListQuery {
	query := (&GroceryListClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(grocerylist.Table, grocerylist.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.GroceryListsTable, user.GroceryListsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroceryListShares queries the grocery_list_shares edge of a User.
func (c *UserClient) QueryGroceryListShares(u *User) *GroceryListShareQuery {
	query := (&GroceryListShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(grocerylistshare.Table, grocerylistshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.GroceryListSharesTable, user.GroceryListSharesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMovieCollections queries the movie_collections edge of a User.
func (c *UserClient) QueryMovieCollections(u *User) *MovieCollectionQuery {
	query := (&MovieCollectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(moviecollection.Table, moviecollection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MovieCollectionsTable, user.MovieCollectionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMovieCollectionShares queries the movie_collection_shares edge of a User.
func (c *UserClient) QueryMovieCollectionShares(u *User) *MovieCollectionShareQuery {
	query := (&MovieCollectionShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(moviecollectionshare.Table, moviecollectionshare.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MovieCollectionSharesTable, user.MovieCollectionSharesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AmazonList, AmazonOrder, AmazonShare, Drink, GroceryList, GroceryListItem,
		GroceryListShare, Movie, MovieCollection, MovieCollectionShare, User []ent.Hook
	}
	inters struct {
		AmazonList, AmazonOrder, AmazonShare, Drink, GroceryList, GroceryListItem,
		GroceryListShare, Movie, MovieCollection, MovieCollectionShare,
		User []ent.Interceptor
	}
)
