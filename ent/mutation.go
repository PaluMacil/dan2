// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/PaluMacil/dan2/ent/amazonlist"
	"github.com/PaluMacil/dan2/ent/amazonorder"
	"github.com/PaluMacil/dan2/ent/amazonshare"
	"github.com/PaluMacil/dan2/ent/drink"
	"github.com/PaluMacil/dan2/ent/grocerylist"
	"github.com/PaluMacil/dan2/ent/grocerylistitem"
	"github.com/PaluMacil/dan2/ent/grocerylistshare"
	"github.com/PaluMacil/dan2/ent/movie"
	"github.com/PaluMacil/dan2/ent/movielist"
	"github.com/PaluMacil/dan2/ent/movielistshare"
	"github.com/PaluMacil/dan2/ent/predicate"
	"github.com/PaluMacil/dan2/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAmazonList       = "AmazonList"
	TypeAmazonOrder      = "AmazonOrder"
	TypeAmazonShare      = "AmazonShare"
	TypeDrink            = "Drink"
	TypeGroceryList      = "GroceryList"
	TypeGroceryListItem  = "GroceryListItem"
	TypeGroceryListShare = "GroceryListShare"
	TypeMovie            = "Movie"
	TypeMovieList        = "MovieList"
	TypeMovieListShare   = "MovieListShare"
	TypeUser             = "User"
)

// AmazonListMutation represents an operation that mutates the AmazonList nodes in the graph.
type AmazonListMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	clearedFields        map[string]struct{}
	amazon_orders        map[int]struct{}
	removedamazon_orders map[int]struct{}
	clearedamazon_orders bool
	owner                map[int]struct{}
	removedowner         map[int]struct{}
	clearedowner         bool
	amazon_shares        map[int]struct{}
	removedamazon_shares map[int]struct{}
	clearedamazon_shares bool
	done                 bool
	oldValue             func(context.Context) (*AmazonList, error)
	predicates           []predicate.AmazonList
}

var _ ent.Mutation = (*AmazonListMutation)(nil)

// amazonlistOption allows management of the mutation configuration using functional options.
type amazonlistOption func(*AmazonListMutation)

// newAmazonListMutation creates new mutation for the AmazonList entity.
func newAmazonListMutation(c config, op Op, opts ...amazonlistOption) *AmazonListMutation {
	m := &AmazonListMutation{
		config:        c,
		op:            op,
		typ:           TypeAmazonList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAmazonListID sets the ID field of the mutation.
func withAmazonListID(id int) amazonlistOption {
	return func(m *AmazonListMutation) {
		var (
			err   error
			once  sync.Once
			value *AmazonList
		)
		m.oldValue = func(ctx context.Context) (*AmazonList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AmazonList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAmazonList sets the old AmazonList of the mutation.
func withAmazonList(node *AmazonList) amazonlistOption {
	return func(m *AmazonListMutation) {
		m.oldValue = func(context.Context) (*AmazonList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AmazonListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AmazonListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AmazonListMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AmazonListMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AmazonList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AmazonListMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AmazonListMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AmazonList entity.
// If the AmazonList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonListMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AmazonListMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddAmazonOrderIDs adds the "amazon_orders" edge to the AmazonOrder entity by ids.
func (m *AmazonListMutation) AddAmazonOrderIDs(ids ...int) {
	if m.amazon_orders == nil {
		m.amazon_orders = make(map[int]struct{})
	}
	for i := range ids {
		m.amazon_orders[ids[i]] = struct{}{}
	}
}

// ClearAmazonOrders clears the "amazon_orders" edge to the AmazonOrder entity.
func (m *AmazonListMutation) ClearAmazonOrders() {
	m.clearedamazon_orders = true
}

// AmazonOrdersCleared reports if the "amazon_orders" edge to the AmazonOrder entity was cleared.
func (m *AmazonListMutation) AmazonOrdersCleared() bool {
	return m.clearedamazon_orders
}

// RemoveAmazonOrderIDs removes the "amazon_orders" edge to the AmazonOrder entity by IDs.
func (m *AmazonListMutation) RemoveAmazonOrderIDs(ids ...int) {
	if m.removedamazon_orders == nil {
		m.removedamazon_orders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.amazon_orders, ids[i])
		m.removedamazon_orders[ids[i]] = struct{}{}
	}
}

// RemovedAmazonOrders returns the removed IDs of the "amazon_orders" edge to the AmazonOrder entity.
func (m *AmazonListMutation) RemovedAmazonOrdersIDs() (ids []int) {
	for id := range m.removedamazon_orders {
		ids = append(ids, id)
	}
	return
}

// AmazonOrdersIDs returns the "amazon_orders" edge IDs in the mutation.
func (m *AmazonListMutation) AmazonOrdersIDs() (ids []int) {
	for id := range m.amazon_orders {
		ids = append(ids, id)
	}
	return
}

// ResetAmazonOrders resets all changes to the "amazon_orders" edge.
func (m *AmazonListMutation) ResetAmazonOrders() {
	m.amazon_orders = nil
	m.clearedamazon_orders = false
	m.removedamazon_orders = nil
}

// AddOwnerIDs adds the "owner" edge to the User entity by ids.
func (m *AmazonListMutation) AddOwnerIDs(ids ...int) {
	if m.owner == nil {
		m.owner = make(map[int]struct{})
	}
	for i := range ids {
		m.owner[ids[i]] = struct{}{}
	}
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AmazonListMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AmazonListMutation) OwnerCleared() bool {
	return m.clearedowner
}

// RemoveOwnerIDs removes the "owner" edge to the User entity by IDs.
func (m *AmazonListMutation) RemoveOwnerIDs(ids ...int) {
	if m.removedowner == nil {
		m.removedowner = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner, ids[i])
		m.removedowner[ids[i]] = struct{}{}
	}
}

// RemovedOwner returns the removed IDs of the "owner" edge to the User entity.
func (m *AmazonListMutation) RemovedOwnerIDs() (ids []int) {
	for id := range m.removedowner {
		ids = append(ids, id)
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
func (m *AmazonListMutation) OwnerIDs() (ids []int) {
	for id := range m.owner {
		ids = append(ids, id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AmazonListMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
	m.removedowner = nil
}

// AddAmazonShareIDs adds the "amazon_shares" edge to the AmazonShare entity by ids.
func (m *AmazonListMutation) AddAmazonShareIDs(ids ...int) {
	if m.amazon_shares == nil {
		m.amazon_shares = make(map[int]struct{})
	}
	for i := range ids {
		m.amazon_shares[ids[i]] = struct{}{}
	}
}

// ClearAmazonShares clears the "amazon_shares" edge to the AmazonShare entity.
func (m *AmazonListMutation) ClearAmazonShares() {
	m.clearedamazon_shares = true
}

// AmazonSharesCleared reports if the "amazon_shares" edge to the AmazonShare entity was cleared.
func (m *AmazonListMutation) AmazonSharesCleared() bool {
	return m.clearedamazon_shares
}

// RemoveAmazonShareIDs removes the "amazon_shares" edge to the AmazonShare entity by IDs.
func (m *AmazonListMutation) RemoveAmazonShareIDs(ids ...int) {
	if m.removedamazon_shares == nil {
		m.removedamazon_shares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.amazon_shares, ids[i])
		m.removedamazon_shares[ids[i]] = struct{}{}
	}
}

// RemovedAmazonShares returns the removed IDs of the "amazon_shares" edge to the AmazonShare entity.
func (m *AmazonListMutation) RemovedAmazonSharesIDs() (ids []int) {
	for id := range m.removedamazon_shares {
		ids = append(ids, id)
	}
	return
}

// AmazonSharesIDs returns the "amazon_shares" edge IDs in the mutation.
func (m *AmazonListMutation) AmazonSharesIDs() (ids []int) {
	for id := range m.amazon_shares {
		ids = append(ids, id)
	}
	return
}

// ResetAmazonShares resets all changes to the "amazon_shares" edge.
func (m *AmazonListMutation) ResetAmazonShares() {
	m.amazon_shares = nil
	m.clearedamazon_shares = false
	m.removedamazon_shares = nil
}

// Where appends a list predicates to the AmazonListMutation builder.
func (m *AmazonListMutation) Where(ps ...predicate.AmazonList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AmazonListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AmazonListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AmazonList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AmazonListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AmazonListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AmazonList).
func (m *AmazonListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AmazonListMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, amazonlist.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AmazonListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case amazonlist.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AmazonListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case amazonlist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AmazonList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmazonListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case amazonlist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AmazonList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AmazonListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AmazonListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmazonListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AmazonList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AmazonListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AmazonListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AmazonListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AmazonList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AmazonListMutation) ResetField(name string) error {
	switch name {
	case amazonlist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AmazonList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AmazonListMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.amazon_orders != nil {
		edges = append(edges, amazonlist.EdgeAmazonOrders)
	}
	if m.owner != nil {
		edges = append(edges, amazonlist.EdgeOwner)
	}
	if m.amazon_shares != nil {
		edges = append(edges, amazonlist.EdgeAmazonShares)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AmazonListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case amazonlist.EdgeAmazonOrders:
		ids := make([]ent.Value, 0, len(m.amazon_orders))
		for id := range m.amazon_orders {
			ids = append(ids, id)
		}
		return ids
	case amazonlist.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.owner))
		for id := range m.owner {
			ids = append(ids, id)
		}
		return ids
	case amazonlist.EdgeAmazonShares:
		ids := make([]ent.Value, 0, len(m.amazon_shares))
		for id := range m.amazon_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AmazonListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedamazon_orders != nil {
		edges = append(edges, amazonlist.EdgeAmazonOrders)
	}
	if m.removedowner != nil {
		edges = append(edges, amazonlist.EdgeOwner)
	}
	if m.removedamazon_shares != nil {
		edges = append(edges, amazonlist.EdgeAmazonShares)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AmazonListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case amazonlist.EdgeAmazonOrders:
		ids := make([]ent.Value, 0, len(m.removedamazon_orders))
		for id := range m.removedamazon_orders {
			ids = append(ids, id)
		}
		return ids
	case amazonlist.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.removedowner))
		for id := range m.removedowner {
			ids = append(ids, id)
		}
		return ids
	case amazonlist.EdgeAmazonShares:
		ids := make([]ent.Value, 0, len(m.removedamazon_shares))
		for id := range m.removedamazon_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AmazonListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedamazon_orders {
		edges = append(edges, amazonlist.EdgeAmazonOrders)
	}
	if m.clearedowner {
		edges = append(edges, amazonlist.EdgeOwner)
	}
	if m.clearedamazon_shares {
		edges = append(edges, amazonlist.EdgeAmazonShares)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AmazonListMutation) EdgeCleared(name string) bool {
	switch name {
	case amazonlist.EdgeAmazonOrders:
		return m.clearedamazon_orders
	case amazonlist.EdgeOwner:
		return m.clearedowner
	case amazonlist.EdgeAmazonShares:
		return m.clearedamazon_shares
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AmazonListMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AmazonList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AmazonListMutation) ResetEdge(name string) error {
	switch name {
	case amazonlist.EdgeAmazonOrders:
		m.ResetAmazonOrders()
		return nil
	case amazonlist.EdgeOwner:
		m.ResetOwner()
		return nil
	case amazonlist.EdgeAmazonShares:
		m.ResetAmazonShares()
		return nil
	}
	return fmt.Errorf("unknown AmazonList edge %s", name)
}

// AmazonOrderMutation represents an operation that mutates the AmazonOrder nodes in the graph.
type AmazonOrderMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	category           *string
	brand              *string
	seller             *string
	address1           *string
	address2           *string
	city               *string
	state              *string
	zip                *string
	price              *float32
	addprice           *float32
	tax                *float32
	addtax             *float32
	refund             *bool
	ordered_at         *time.Time
	created_at         *time.Time
	clearedFields      map[string]struct{}
	amazon_list        *int
	clearedamazon_list bool
	done               bool
	oldValue           func(context.Context) (*AmazonOrder, error)
	predicates         []predicate.AmazonOrder
}

var _ ent.Mutation = (*AmazonOrderMutation)(nil)

// amazonorderOption allows management of the mutation configuration using functional options.
type amazonorderOption func(*AmazonOrderMutation)

// newAmazonOrderMutation creates new mutation for the AmazonOrder entity.
func newAmazonOrderMutation(c config, op Op, opts ...amazonorderOption) *AmazonOrderMutation {
	m := &AmazonOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeAmazonOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAmazonOrderID sets the ID field of the mutation.
func withAmazonOrderID(id int) amazonorderOption {
	return func(m *AmazonOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *AmazonOrder
		)
		m.oldValue = func(ctx context.Context) (*AmazonOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AmazonOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAmazonOrder sets the old AmazonOrder of the mutation.
func withAmazonOrder(node *AmazonOrder) amazonorderOption {
	return func(m *AmazonOrderMutation) {
		m.oldValue = func(context.Context) (*AmazonOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AmazonOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AmazonOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AmazonOrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AmazonOrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AmazonOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AmazonOrderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AmazonOrderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AmazonOrderMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *AmazonOrderMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *AmazonOrderMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *AmazonOrderMutation) ResetCategory() {
	m.category = nil
}

// SetBrand sets the "brand" field.
func (m *AmazonOrderMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *AmazonOrderMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *AmazonOrderMutation) ResetBrand() {
	m.brand = nil
}

// SetSeller sets the "seller" field.
func (m *AmazonOrderMutation) SetSeller(s string) {
	m.seller = &s
}

// Seller returns the value of the "seller" field in the mutation.
func (m *AmazonOrderMutation) Seller() (r string, exists bool) {
	v := m.seller
	if v == nil {
		return
	}
	return *v, true
}

// OldSeller returns the old "seller" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldSeller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeller: %w", err)
	}
	return oldValue.Seller, nil
}

// ResetSeller resets all changes to the "seller" field.
func (m *AmazonOrderMutation) ResetSeller() {
	m.seller = nil
}

// SetAddress1 sets the "address1" field.
func (m *AmazonOrderMutation) SetAddress1(s string) {
	m.address1 = &s
}

// Address1 returns the value of the "address1" field in the mutation.
func (m *AmazonOrderMutation) Address1() (r string, exists bool) {
	v := m.address1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress1 returns the old "address1" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldAddress1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress1: %w", err)
	}
	return oldValue.Address1, nil
}

// ResetAddress1 resets all changes to the "address1" field.
func (m *AmazonOrderMutation) ResetAddress1() {
	m.address1 = nil
}

// SetAddress2 sets the "address2" field.
func (m *AmazonOrderMutation) SetAddress2(s string) {
	m.address2 = &s
}

// Address2 returns the value of the "address2" field in the mutation.
func (m *AmazonOrderMutation) Address2() (r string, exists bool) {
	v := m.address2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress2 returns the old "address2" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldAddress2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress2: %w", err)
	}
	return oldValue.Address2, nil
}

// ResetAddress2 resets all changes to the "address2" field.
func (m *AmazonOrderMutation) ResetAddress2() {
	m.address2 = nil
}

// SetCity sets the "city" field.
func (m *AmazonOrderMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AmazonOrderMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AmazonOrderMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *AmazonOrderMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AmazonOrderMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AmazonOrderMutation) ResetState() {
	m.state = nil
}

// SetZip sets the "zip" field.
func (m *AmazonOrderMutation) SetZip(s string) {
	m.zip = &s
}

// Zip returns the value of the "zip" field in the mutation.
func (m *AmazonOrderMutation) Zip() (r string, exists bool) {
	v := m.zip
	if v == nil {
		return
	}
	return *v, true
}

// OldZip returns the old "zip" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldZip(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZip: %w", err)
	}
	return oldValue.Zip, nil
}

// ResetZip resets all changes to the "zip" field.
func (m *AmazonOrderMutation) ResetZip() {
	m.zip = nil
}

// SetPrice sets the "price" field.
func (m *AmazonOrderMutation) SetPrice(f float32) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *AmazonOrderMutation) Price() (r float32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldPrice(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *AmazonOrderMutation) AddPrice(f float32) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *AmazonOrderMutation) AddedPrice() (r float32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *AmazonOrderMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetTax sets the "tax" field.
func (m *AmazonOrderMutation) SetTax(f float32) {
	m.tax = &f
	m.addtax = nil
}

// Tax returns the value of the "tax" field in the mutation.
func (m *AmazonOrderMutation) Tax() (r float32, exists bool) {
	v := m.tax
	if v == nil {
		return
	}
	return *v, true
}

// OldTax returns the old "tax" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldTax(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTax: %w", err)
	}
	return oldValue.Tax, nil
}

// AddTax adds f to the "tax" field.
func (m *AmazonOrderMutation) AddTax(f float32) {
	if m.addtax != nil {
		*m.addtax += f
	} else {
		m.addtax = &f
	}
}

// AddedTax returns the value that was added to the "tax" field in this mutation.
func (m *AmazonOrderMutation) AddedTax() (r float32, exists bool) {
	v := m.addtax
	if v == nil {
		return
	}
	return *v, true
}

// ResetTax resets all changes to the "tax" field.
func (m *AmazonOrderMutation) ResetTax() {
	m.tax = nil
	m.addtax = nil
}

// SetRefund sets the "refund" field.
func (m *AmazonOrderMutation) SetRefund(b bool) {
	m.refund = &b
}

// Refund returns the value of the "refund" field in the mutation.
func (m *AmazonOrderMutation) Refund() (r bool, exists bool) {
	v := m.refund
	if v == nil {
		return
	}
	return *v, true
}

// OldRefund returns the old "refund" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldRefund(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefund is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefund requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefund: %w", err)
	}
	return oldValue.Refund, nil
}

// ResetRefund resets all changes to the "refund" field.
func (m *AmazonOrderMutation) ResetRefund() {
	m.refund = nil
}

// SetOrderedAt sets the "ordered_at" field.
func (m *AmazonOrderMutation) SetOrderedAt(t time.Time) {
	m.ordered_at = &t
}

// OrderedAt returns the value of the "ordered_at" field in the mutation.
func (m *AmazonOrderMutation) OrderedAt() (r time.Time, exists bool) {
	v := m.ordered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderedAt returns the old "ordered_at" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldOrderedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderedAt: %w", err)
	}
	return oldValue.OrderedAt, nil
}

// ResetOrderedAt resets all changes to the "ordered_at" field.
func (m *AmazonOrderMutation) ResetOrderedAt() {
	m.ordered_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AmazonOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AmazonOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AmazonOrder entity.
// If the AmazonOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AmazonOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAmazonListID sets the "amazon_list" edge to the AmazonList entity by id.
func (m *AmazonOrderMutation) SetAmazonListID(id int) {
	m.amazon_list = &id
}

// ClearAmazonList clears the "amazon_list" edge to the AmazonList entity.
func (m *AmazonOrderMutation) ClearAmazonList() {
	m.clearedamazon_list = true
}

// AmazonListCleared reports if the "amazon_list" edge to the AmazonList entity was cleared.
func (m *AmazonOrderMutation) AmazonListCleared() bool {
	return m.clearedamazon_list
}

// AmazonListID returns the "amazon_list" edge ID in the mutation.
func (m *AmazonOrderMutation) AmazonListID() (id int, exists bool) {
	if m.amazon_list != nil {
		return *m.amazon_list, true
	}
	return
}

// AmazonListIDs returns the "amazon_list" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AmazonListID instead. It exists only for internal usage by the builders.
func (m *AmazonOrderMutation) AmazonListIDs() (ids []int) {
	if id := m.amazon_list; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAmazonList resets all changes to the "amazon_list" edge.
func (m *AmazonOrderMutation) ResetAmazonList() {
	m.amazon_list = nil
	m.clearedamazon_list = false
}

// Where appends a list predicates to the AmazonOrderMutation builder.
func (m *AmazonOrderMutation) Where(ps ...predicate.AmazonOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AmazonOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AmazonOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AmazonOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AmazonOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AmazonOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AmazonOrder).
func (m *AmazonOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AmazonOrderMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, amazonorder.FieldName)
	}
	if m.category != nil {
		fields = append(fields, amazonorder.FieldCategory)
	}
	if m.brand != nil {
		fields = append(fields, amazonorder.FieldBrand)
	}
	if m.seller != nil {
		fields = append(fields, amazonorder.FieldSeller)
	}
	if m.address1 != nil {
		fields = append(fields, amazonorder.FieldAddress1)
	}
	if m.address2 != nil {
		fields = append(fields, amazonorder.FieldAddress2)
	}
	if m.city != nil {
		fields = append(fields, amazonorder.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, amazonorder.FieldState)
	}
	if m.zip != nil {
		fields = append(fields, amazonorder.FieldZip)
	}
	if m.price != nil {
		fields = append(fields, amazonorder.FieldPrice)
	}
	if m.tax != nil {
		fields = append(fields, amazonorder.FieldTax)
	}
	if m.refund != nil {
		fields = append(fields, amazonorder.FieldRefund)
	}
	if m.ordered_at != nil {
		fields = append(fields, amazonorder.FieldOrderedAt)
	}
	if m.created_at != nil {
		fields = append(fields, amazonorder.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AmazonOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case amazonorder.FieldName:
		return m.Name()
	case amazonorder.FieldCategory:
		return m.Category()
	case amazonorder.FieldBrand:
		return m.Brand()
	case amazonorder.FieldSeller:
		return m.Seller()
	case amazonorder.FieldAddress1:
		return m.Address1()
	case amazonorder.FieldAddress2:
		return m.Address2()
	case amazonorder.FieldCity:
		return m.City()
	case amazonorder.FieldState:
		return m.State()
	case amazonorder.FieldZip:
		return m.Zip()
	case amazonorder.FieldPrice:
		return m.Price()
	case amazonorder.FieldTax:
		return m.Tax()
	case amazonorder.FieldRefund:
		return m.Refund()
	case amazonorder.FieldOrderedAt:
		return m.OrderedAt()
	case amazonorder.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AmazonOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case amazonorder.FieldName:
		return m.OldName(ctx)
	case amazonorder.FieldCategory:
		return m.OldCategory(ctx)
	case amazonorder.FieldBrand:
		return m.OldBrand(ctx)
	case amazonorder.FieldSeller:
		return m.OldSeller(ctx)
	case amazonorder.FieldAddress1:
		return m.OldAddress1(ctx)
	case amazonorder.FieldAddress2:
		return m.OldAddress2(ctx)
	case amazonorder.FieldCity:
		return m.OldCity(ctx)
	case amazonorder.FieldState:
		return m.OldState(ctx)
	case amazonorder.FieldZip:
		return m.OldZip(ctx)
	case amazonorder.FieldPrice:
		return m.OldPrice(ctx)
	case amazonorder.FieldTax:
		return m.OldTax(ctx)
	case amazonorder.FieldRefund:
		return m.OldRefund(ctx)
	case amazonorder.FieldOrderedAt:
		return m.OldOrderedAt(ctx)
	case amazonorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AmazonOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmazonOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case amazonorder.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case amazonorder.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case amazonorder.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case amazonorder.FieldSeller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeller(v)
		return nil
	case amazonorder.FieldAddress1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress1(v)
		return nil
	case amazonorder.FieldAddress2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress2(v)
		return nil
	case amazonorder.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case amazonorder.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case amazonorder.FieldZip:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZip(v)
		return nil
	case amazonorder.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case amazonorder.FieldTax:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTax(v)
		return nil
	case amazonorder.FieldRefund:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefund(v)
		return nil
	case amazonorder.FieldOrderedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderedAt(v)
		return nil
	case amazonorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AmazonOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AmazonOrderMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, amazonorder.FieldPrice)
	}
	if m.addtax != nil {
		fields = append(fields, amazonorder.FieldTax)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AmazonOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case amazonorder.FieldPrice:
		return m.AddedPrice()
	case amazonorder.FieldTax:
		return m.AddedTax()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmazonOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case amazonorder.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case amazonorder.FieldTax:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTax(v)
		return nil
	}
	return fmt.Errorf("unknown AmazonOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AmazonOrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AmazonOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AmazonOrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AmazonOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AmazonOrderMutation) ResetField(name string) error {
	switch name {
	case amazonorder.FieldName:
		m.ResetName()
		return nil
	case amazonorder.FieldCategory:
		m.ResetCategory()
		return nil
	case amazonorder.FieldBrand:
		m.ResetBrand()
		return nil
	case amazonorder.FieldSeller:
		m.ResetSeller()
		return nil
	case amazonorder.FieldAddress1:
		m.ResetAddress1()
		return nil
	case amazonorder.FieldAddress2:
		m.ResetAddress2()
		return nil
	case amazonorder.FieldCity:
		m.ResetCity()
		return nil
	case amazonorder.FieldState:
		m.ResetState()
		return nil
	case amazonorder.FieldZip:
		m.ResetZip()
		return nil
	case amazonorder.FieldPrice:
		m.ResetPrice()
		return nil
	case amazonorder.FieldTax:
		m.ResetTax()
		return nil
	case amazonorder.FieldRefund:
		m.ResetRefund()
		return nil
	case amazonorder.FieldOrderedAt:
		m.ResetOrderedAt()
		return nil
	case amazonorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AmazonOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AmazonOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.amazon_list != nil {
		edges = append(edges, amazonorder.EdgeAmazonList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AmazonOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case amazonorder.EdgeAmazonList:
		if id := m.amazon_list; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AmazonOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AmazonOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AmazonOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedamazon_list {
		edges = append(edges, amazonorder.EdgeAmazonList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AmazonOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case amazonorder.EdgeAmazonList:
		return m.clearedamazon_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AmazonOrderMutation) ClearEdge(name string) error {
	switch name {
	case amazonorder.EdgeAmazonList:
		m.ClearAmazonList()
		return nil
	}
	return fmt.Errorf("unknown AmazonOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AmazonOrderMutation) ResetEdge(name string) error {
	switch name {
	case amazonorder.EdgeAmazonList:
		m.ResetAmazonList()
		return nil
	}
	return fmt.Errorf("unknown AmazonOrder edge %s", name)
}

// AmazonShareMutation represents an operation that mutates the AmazonShare nodes in the graph.
type AmazonShareMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	can_edit           *bool
	created_at         *time.Time
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	amazon_list        *int
	clearedamazon_list bool
	done               bool
	oldValue           func(context.Context) (*AmazonShare, error)
	predicates         []predicate.AmazonShare
}

var _ ent.Mutation = (*AmazonShareMutation)(nil)

// amazonshareOption allows management of the mutation configuration using functional options.
type amazonshareOption func(*AmazonShareMutation)

// newAmazonShareMutation creates new mutation for the AmazonShare entity.
func newAmazonShareMutation(c config, op Op, opts ...amazonshareOption) *AmazonShareMutation {
	m := &AmazonShareMutation{
		config:        c,
		op:            op,
		typ:           TypeAmazonShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAmazonShareID sets the ID field of the mutation.
func withAmazonShareID(id int) amazonshareOption {
	return func(m *AmazonShareMutation) {
		var (
			err   error
			once  sync.Once
			value *AmazonShare
		)
		m.oldValue = func(ctx context.Context) (*AmazonShare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AmazonShare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAmazonShare sets the old AmazonShare of the mutation.
func withAmazonShare(node *AmazonShare) amazonshareOption {
	return func(m *AmazonShareMutation) {
		m.oldValue = func(context.Context) (*AmazonShare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AmazonShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AmazonShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AmazonShareMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AmazonShareMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AmazonShare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCanEdit sets the "can_edit" field.
func (m *AmazonShareMutation) SetCanEdit(b bool) {
	m.can_edit = &b
}

// CanEdit returns the value of the "can_edit" field in the mutation.
func (m *AmazonShareMutation) CanEdit() (r bool, exists bool) {
	v := m.can_edit
	if v == nil {
		return
	}
	return *v, true
}

// OldCanEdit returns the old "can_edit" field's value of the AmazonShare entity.
// If the AmazonShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonShareMutation) OldCanEdit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanEdit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanEdit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanEdit: %w", err)
	}
	return oldValue.CanEdit, nil
}

// ResetCanEdit resets all changes to the "can_edit" field.
func (m *AmazonShareMutation) ResetCanEdit() {
	m.can_edit = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AmazonShareMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AmazonShareMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AmazonShare entity.
// If the AmazonShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AmazonShareMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AmazonShareMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AmazonShareMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AmazonShareMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AmazonShareMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AmazonShareMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AmazonShareMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AmazonShareMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAmazonListID sets the "amazon_list" edge to the AmazonList entity by id.
func (m *AmazonShareMutation) SetAmazonListID(id int) {
	m.amazon_list = &id
}

// ClearAmazonList clears the "amazon_list" edge to the AmazonList entity.
func (m *AmazonShareMutation) ClearAmazonList() {
	m.clearedamazon_list = true
}

// AmazonListCleared reports if the "amazon_list" edge to the AmazonList entity was cleared.
func (m *AmazonShareMutation) AmazonListCleared() bool {
	return m.clearedamazon_list
}

// AmazonListID returns the "amazon_list" edge ID in the mutation.
func (m *AmazonShareMutation) AmazonListID() (id int, exists bool) {
	if m.amazon_list != nil {
		return *m.amazon_list, true
	}
	return
}

// AmazonListIDs returns the "amazon_list" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AmazonListID instead. It exists only for internal usage by the builders.
func (m *AmazonShareMutation) AmazonListIDs() (ids []int) {
	if id := m.amazon_list; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAmazonList resets all changes to the "amazon_list" edge.
func (m *AmazonShareMutation) ResetAmazonList() {
	m.amazon_list = nil
	m.clearedamazon_list = false
}

// Where appends a list predicates to the AmazonShareMutation builder.
func (m *AmazonShareMutation) Where(ps ...predicate.AmazonShare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AmazonShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AmazonShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AmazonShare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AmazonShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AmazonShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AmazonShare).
func (m *AmazonShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AmazonShareMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.can_edit != nil {
		fields = append(fields, amazonshare.FieldCanEdit)
	}
	if m.created_at != nil {
		fields = append(fields, amazonshare.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AmazonShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case amazonshare.FieldCanEdit:
		return m.CanEdit()
	case amazonshare.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AmazonShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case amazonshare.FieldCanEdit:
		return m.OldCanEdit(ctx)
	case amazonshare.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AmazonShare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmazonShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case amazonshare.FieldCanEdit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanEdit(v)
		return nil
	case amazonshare.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AmazonShare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AmazonShareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AmazonShareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AmazonShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AmazonShare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AmazonShareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AmazonShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AmazonShareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AmazonShare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AmazonShareMutation) ResetField(name string) error {
	switch name {
	case amazonshare.FieldCanEdit:
		m.ResetCanEdit()
		return nil
	case amazonshare.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AmazonShare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AmazonShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, amazonshare.EdgeUser)
	}
	if m.amazon_list != nil {
		edges = append(edges, amazonshare.EdgeAmazonList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AmazonShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case amazonshare.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case amazonshare.EdgeAmazonList:
		if id := m.amazon_list; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AmazonShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AmazonShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AmazonShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, amazonshare.EdgeUser)
	}
	if m.clearedamazon_list {
		edges = append(edges, amazonshare.EdgeAmazonList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AmazonShareMutation) EdgeCleared(name string) bool {
	switch name {
	case amazonshare.EdgeUser:
		return m.cleareduser
	case amazonshare.EdgeAmazonList:
		return m.clearedamazon_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AmazonShareMutation) ClearEdge(name string) error {
	switch name {
	case amazonshare.EdgeUser:
		m.ClearUser()
		return nil
	case amazonshare.EdgeAmazonList:
		m.ClearAmazonList()
		return nil
	}
	return fmt.Errorf("unknown AmazonShare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AmazonShareMutation) ResetEdge(name string) error {
	switch name {
	case amazonshare.EdgeUser:
		m.ResetUser()
		return nil
	case amazonshare.EdgeAmazonList:
		m.ResetAmazonList()
		return nil
	}
	return fmt.Errorf("unknown AmazonShare edge %s", name)
}

// DrinkMutation represents an operation that mutates the Drink nodes in the graph.
type DrinkMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *drink.Type
	abv           *int8
	addabv        *int8
	ounces        *int8
	addounces     *int8
	year          *int
	addyear       *int
	month         *int
	addmonth      *int
	day           *int
	addday        *int
	note          *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Drink, error)
	predicates    []predicate.Drink
}

var _ ent.Mutation = (*DrinkMutation)(nil)

// drinkOption allows management of the mutation configuration using functional options.
type drinkOption func(*DrinkMutation)

// newDrinkMutation creates new mutation for the Drink entity.
func newDrinkMutation(c config, op Op, opts ...drinkOption) *DrinkMutation {
	m := &DrinkMutation{
		config:        c,
		op:            op,
		typ:           TypeDrink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDrinkID sets the ID field of the mutation.
func withDrinkID(id int) drinkOption {
	return func(m *DrinkMutation) {
		var (
			err   error
			once  sync.Once
			value *Drink
		)
		m.oldValue = func(ctx context.Context) (*Drink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Drink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDrink sets the old Drink of the mutation.
func withDrink(node *Drink) drinkOption {
	return func(m *DrinkMutation) {
		m.oldValue = func(context.Context) (*Drink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DrinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DrinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DrinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DrinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Drink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *DrinkMutation) SetType(d drink.Type) {
	m._type = &d
}

// GetType returns the value of the "type" field in the mutation.
func (m *DrinkMutation) GetType() (r drink.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Drink entity.
// If the Drink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DrinkMutation) OldType(ctx context.Context) (v drink.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DrinkMutation) ResetType() {
	m._type = nil
}

// SetAbv sets the "abv" field.
func (m *DrinkMutation) SetAbv(i int8) {
	m.abv = &i
	m.addabv = nil
}

// Abv returns the value of the "abv" field in the mutation.
func (m *DrinkMutation) Abv() (r int8, exists bool) {
	v := m.abv
	if v == nil {
		return
	}
	return *v, true
}

// OldAbv returns the old "abv" field's value of the Drink entity.
// If the Drink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DrinkMutation) OldAbv(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbv: %w", err)
	}
	return oldValue.Abv, nil
}

// AddAbv adds i to the "abv" field.
func (m *DrinkMutation) AddAbv(i int8) {
	if m.addabv != nil {
		*m.addabv += i
	} else {
		m.addabv = &i
	}
}

// AddedAbv returns the value that was added to the "abv" field in this mutation.
func (m *DrinkMutation) AddedAbv() (r int8, exists bool) {
	v := m.addabv
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbv resets all changes to the "abv" field.
func (m *DrinkMutation) ResetAbv() {
	m.abv = nil
	m.addabv = nil
}

// SetOunces sets the "ounces" field.
func (m *DrinkMutation) SetOunces(i int8) {
	m.ounces = &i
	m.addounces = nil
}

// Ounces returns the value of the "ounces" field in the mutation.
func (m *DrinkMutation) Ounces() (r int8, exists bool) {
	v := m.ounces
	if v == nil {
		return
	}
	return *v, true
}

// OldOunces returns the old "ounces" field's value of the Drink entity.
// If the Drink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DrinkMutation) OldOunces(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOunces is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOunces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOunces: %w", err)
	}
	return oldValue.Ounces, nil
}

// AddOunces adds i to the "ounces" field.
func (m *DrinkMutation) AddOunces(i int8) {
	if m.addounces != nil {
		*m.addounces += i
	} else {
		m.addounces = &i
	}
}

// AddedOunces returns the value that was added to the "ounces" field in this mutation.
func (m *DrinkMutation) AddedOunces() (r int8, exists bool) {
	v := m.addounces
	if v == nil {
		return
	}
	return *v, true
}

// ResetOunces resets all changes to the "ounces" field.
func (m *DrinkMutation) ResetOunces() {
	m.ounces = nil
	m.addounces = nil
}

// SetYear sets the "year" field.
func (m *DrinkMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *DrinkMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Drink entity.
// If the Drink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DrinkMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *DrinkMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *DrinkMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *DrinkMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetMonth sets the "month" field.
func (m *DrinkMutation) SetMonth(i int) {
	m.month = &i
	m.addmonth = nil
}

// Month returns the value of the "month" field in the mutation.
func (m *DrinkMutation) Month() (r int, exists bool) {
	v := m.month
	if v == nil {
		return
	}
	return *v, true
}

// OldMonth returns the old "month" field's value of the Drink entity.
// If the Drink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DrinkMutation) OldMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonth: %w", err)
	}
	return oldValue.Month, nil
}

// AddMonth adds i to the "month" field.
func (m *DrinkMutation) AddMonth(i int) {
	if m.addmonth != nil {
		*m.addmonth += i
	} else {
		m.addmonth = &i
	}
}

// AddedMonth returns the value that was added to the "month" field in this mutation.
func (m *DrinkMutation) AddedMonth() (r int, exists bool) {
	v := m.addmonth
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonth resets all changes to the "month" field.
func (m *DrinkMutation) ResetMonth() {
	m.month = nil
	m.addmonth = nil
}

// SetDay sets the "day" field.
func (m *DrinkMutation) SetDay(i int) {
	m.day = &i
	m.addday = nil
}

// Day returns the value of the "day" field in the mutation.
func (m *DrinkMutation) Day() (r int, exists bool) {
	v := m.day
	if v == nil {
		return
	}
	return *v, true
}

// OldDay returns the old "day" field's value of the Drink entity.
// If the Drink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DrinkMutation) OldDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay: %w", err)
	}
	return oldValue.Day, nil
}

// AddDay adds i to the "day" field.
func (m *DrinkMutation) AddDay(i int) {
	if m.addday != nil {
		*m.addday += i
	} else {
		m.addday = &i
	}
}

// AddedDay returns the value that was added to the "day" field in this mutation.
func (m *DrinkMutation) AddedDay() (r int, exists bool) {
	v := m.addday
	if v == nil {
		return
	}
	return *v, true
}

// ResetDay resets all changes to the "day" field.
func (m *DrinkMutation) ResetDay() {
	m.day = nil
	m.addday = nil
}

// SetNote sets the "note" field.
func (m *DrinkMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *DrinkMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Drink entity.
// If the Drink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DrinkMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *DrinkMutation) ResetNote() {
	m.note = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DrinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DrinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Drink entity.
// If the Drink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DrinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DrinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *DrinkMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *DrinkMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *DrinkMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *DrinkMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DrinkMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DrinkMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the DrinkMutation builder.
func (m *DrinkMutation) Where(ps ...predicate.Drink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DrinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DrinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Drink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DrinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DrinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Drink).
func (m *DrinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DrinkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._type != nil {
		fields = append(fields, drink.FieldType)
	}
	if m.abv != nil {
		fields = append(fields, drink.FieldAbv)
	}
	if m.ounces != nil {
		fields = append(fields, drink.FieldOunces)
	}
	if m.year != nil {
		fields = append(fields, drink.FieldYear)
	}
	if m.month != nil {
		fields = append(fields, drink.FieldMonth)
	}
	if m.day != nil {
		fields = append(fields, drink.FieldDay)
	}
	if m.note != nil {
		fields = append(fields, drink.FieldNote)
	}
	if m.created_at != nil {
		fields = append(fields, drink.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DrinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case drink.FieldType:
		return m.GetType()
	case drink.FieldAbv:
		return m.Abv()
	case drink.FieldOunces:
		return m.Ounces()
	case drink.FieldYear:
		return m.Year()
	case drink.FieldMonth:
		return m.Month()
	case drink.FieldDay:
		return m.Day()
	case drink.FieldNote:
		return m.Note()
	case drink.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DrinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case drink.FieldType:
		return m.OldType(ctx)
	case drink.FieldAbv:
		return m.OldAbv(ctx)
	case drink.FieldOunces:
		return m.OldOunces(ctx)
	case drink.FieldYear:
		return m.OldYear(ctx)
	case drink.FieldMonth:
		return m.OldMonth(ctx)
	case drink.FieldDay:
		return m.OldDay(ctx)
	case drink.FieldNote:
		return m.OldNote(ctx)
	case drink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Drink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DrinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case drink.FieldType:
		v, ok := value.(drink.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case drink.FieldAbv:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbv(v)
		return nil
	case drink.FieldOunces:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOunces(v)
		return nil
	case drink.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case drink.FieldMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonth(v)
		return nil
	case drink.FieldDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay(v)
		return nil
	case drink.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case drink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Drink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DrinkMutation) AddedFields() []string {
	var fields []string
	if m.addabv != nil {
		fields = append(fields, drink.FieldAbv)
	}
	if m.addounces != nil {
		fields = append(fields, drink.FieldOunces)
	}
	if m.addyear != nil {
		fields = append(fields, drink.FieldYear)
	}
	if m.addmonth != nil {
		fields = append(fields, drink.FieldMonth)
	}
	if m.addday != nil {
		fields = append(fields, drink.FieldDay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DrinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case drink.FieldAbv:
		return m.AddedAbv()
	case drink.FieldOunces:
		return m.AddedOunces()
	case drink.FieldYear:
		return m.AddedYear()
	case drink.FieldMonth:
		return m.AddedMonth()
	case drink.FieldDay:
		return m.AddedDay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DrinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case drink.FieldAbv:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbv(v)
		return nil
	case drink.FieldOunces:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOunces(v)
		return nil
	case drink.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case drink.FieldMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonth(v)
		return nil
	case drink.FieldDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDay(v)
		return nil
	}
	return fmt.Errorf("unknown Drink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DrinkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DrinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DrinkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Drink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DrinkMutation) ResetField(name string) error {
	switch name {
	case drink.FieldType:
		m.ResetType()
		return nil
	case drink.FieldAbv:
		m.ResetAbv()
		return nil
	case drink.FieldOunces:
		m.ResetOunces()
		return nil
	case drink.FieldYear:
		m.ResetYear()
		return nil
	case drink.FieldMonth:
		m.ResetMonth()
		return nil
	case drink.FieldDay:
		m.ResetDay()
		return nil
	case drink.FieldNote:
		m.ResetNote()
		return nil
	case drink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Drink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DrinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, drink.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DrinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case drink.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DrinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DrinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DrinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, drink.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DrinkMutation) EdgeCleared(name string) bool {
	switch name {
	case drink.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DrinkMutation) ClearEdge(name string) error {
	switch name {
	case drink.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Drink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DrinkMutation) ResetEdge(name string) error {
	switch name {
	case drink.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Drink edge %s", name)
}

// GroceryListMutation represents an operation that mutates the GroceryList nodes in the graph.
type GroceryListMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	note                       *string
	archived                   *bool
	created_at                 *time.Time
	clearedFields              map[string]struct{}
	grocery_list_items         map[int]struct{}
	removedgrocery_list_items  map[int]struct{}
	clearedgrocery_list_items  bool
	owner                      *int
	clearedowner               bool
	grocery_list_shares        map[int]struct{}
	removedgrocery_list_shares map[int]struct{}
	clearedgrocery_list_shares bool
	done                       bool
	oldValue                   func(context.Context) (*GroceryList, error)
	predicates                 []predicate.GroceryList
}

var _ ent.Mutation = (*GroceryListMutation)(nil)

// grocerylistOption allows management of the mutation configuration using functional options.
type grocerylistOption func(*GroceryListMutation)

// newGroceryListMutation creates new mutation for the GroceryList entity.
func newGroceryListMutation(c config, op Op, opts ...grocerylistOption) *GroceryListMutation {
	m := &GroceryListMutation{
		config:        c,
		op:            op,
		typ:           TypeGroceryList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroceryListID sets the ID field of the mutation.
func withGroceryListID(id int) grocerylistOption {
	return func(m *GroceryListMutation) {
		var (
			err   error
			once  sync.Once
			value *GroceryList
		)
		m.oldValue = func(ctx context.Context) (*GroceryList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroceryList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroceryList sets the old GroceryList of the mutation.
func withGroceryList(node *GroceryList) grocerylistOption {
	return func(m *GroceryListMutation) {
		m.oldValue = func(context.Context) (*GroceryList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroceryListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroceryListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroceryListMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroceryListMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroceryList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GroceryListMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroceryListMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GroceryList entity.
// If the GroceryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroceryListMutation) ResetName() {
	m.name = nil
}

// SetNote sets the "note" field.
func (m *GroceryListMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *GroceryListMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the GroceryList entity.
// If the GroceryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *GroceryListMutation) ResetNote() {
	m.note = nil
}

// SetArchived sets the "archived" field.
func (m *GroceryListMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *GroceryListMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the GroceryList entity.
// If the GroceryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *GroceryListMutation) ResetArchived() {
	m.archived = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroceryListMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroceryListMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroceryList entity.
// If the GroceryList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroceryListMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddGroceryListItemIDs adds the "grocery_list_items" edge to the GroceryListItem entity by ids.
func (m *GroceryListMutation) AddGroceryListItemIDs(ids ...int) {
	if m.grocery_list_items == nil {
		m.grocery_list_items = make(map[int]struct{})
	}
	for i := range ids {
		m.grocery_list_items[ids[i]] = struct{}{}
	}
}

// ClearGroceryListItems clears the "grocery_list_items" edge to the GroceryListItem entity.
func (m *GroceryListMutation) ClearGroceryListItems() {
	m.clearedgrocery_list_items = true
}

// GroceryListItemsCleared reports if the "grocery_list_items" edge to the GroceryListItem entity was cleared.
func (m *GroceryListMutation) GroceryListItemsCleared() bool {
	return m.clearedgrocery_list_items
}

// RemoveGroceryListItemIDs removes the "grocery_list_items" edge to the GroceryListItem entity by IDs.
func (m *GroceryListMutation) RemoveGroceryListItemIDs(ids ...int) {
	if m.removedgrocery_list_items == nil {
		m.removedgrocery_list_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grocery_list_items, ids[i])
		m.removedgrocery_list_items[ids[i]] = struct{}{}
	}
}

// RemovedGroceryListItems returns the removed IDs of the "grocery_list_items" edge to the GroceryListItem entity.
func (m *GroceryListMutation) RemovedGroceryListItemsIDs() (ids []int) {
	for id := range m.removedgrocery_list_items {
		ids = append(ids, id)
	}
	return
}

// GroceryListItemsIDs returns the "grocery_list_items" edge IDs in the mutation.
func (m *GroceryListMutation) GroceryListItemsIDs() (ids []int) {
	for id := range m.grocery_list_items {
		ids = append(ids, id)
	}
	return
}

// ResetGroceryListItems resets all changes to the "grocery_list_items" edge.
func (m *GroceryListMutation) ResetGroceryListItems() {
	m.grocery_list_items = nil
	m.clearedgrocery_list_items = false
	m.removedgrocery_list_items = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *GroceryListMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *GroceryListMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *GroceryListMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *GroceryListMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *GroceryListMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *GroceryListMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddGroceryListShareIDs adds the "grocery_list_shares" edge to the GroceryListShare entity by ids.
func (m *GroceryListMutation) AddGroceryListShareIDs(ids ...int) {
	if m.grocery_list_shares == nil {
		m.grocery_list_shares = make(map[int]struct{})
	}
	for i := range ids {
		m.grocery_list_shares[ids[i]] = struct{}{}
	}
}

// ClearGroceryListShares clears the "grocery_list_shares" edge to the GroceryListShare entity.
func (m *GroceryListMutation) ClearGroceryListShares() {
	m.clearedgrocery_list_shares = true
}

// GroceryListSharesCleared reports if the "grocery_list_shares" edge to the GroceryListShare entity was cleared.
func (m *GroceryListMutation) GroceryListSharesCleared() bool {
	return m.clearedgrocery_list_shares
}

// RemoveGroceryListShareIDs removes the "grocery_list_shares" edge to the GroceryListShare entity by IDs.
func (m *GroceryListMutation) RemoveGroceryListShareIDs(ids ...int) {
	if m.removedgrocery_list_shares == nil {
		m.removedgrocery_list_shares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grocery_list_shares, ids[i])
		m.removedgrocery_list_shares[ids[i]] = struct{}{}
	}
}

// RemovedGroceryListShares returns the removed IDs of the "grocery_list_shares" edge to the GroceryListShare entity.
func (m *GroceryListMutation) RemovedGroceryListSharesIDs() (ids []int) {
	for id := range m.removedgrocery_list_shares {
		ids = append(ids, id)
	}
	return
}

// GroceryListSharesIDs returns the "grocery_list_shares" edge IDs in the mutation.
func (m *GroceryListMutation) GroceryListSharesIDs() (ids []int) {
	for id := range m.grocery_list_shares {
		ids = append(ids, id)
	}
	return
}

// ResetGroceryListShares resets all changes to the "grocery_list_shares" edge.
func (m *GroceryListMutation) ResetGroceryListShares() {
	m.grocery_list_shares = nil
	m.clearedgrocery_list_shares = false
	m.removedgrocery_list_shares = nil
}

// Where appends a list predicates to the GroceryListMutation builder.
func (m *GroceryListMutation) Where(ps ...predicate.GroceryList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroceryListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroceryListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroceryList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroceryListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroceryListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroceryList).
func (m *GroceryListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroceryListMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, grocerylist.FieldName)
	}
	if m.note != nil {
		fields = append(fields, grocerylist.FieldNote)
	}
	if m.archived != nil {
		fields = append(fields, grocerylist.FieldArchived)
	}
	if m.created_at != nil {
		fields = append(fields, grocerylist.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroceryListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grocerylist.FieldName:
		return m.Name()
	case grocerylist.FieldNote:
		return m.Note()
	case grocerylist.FieldArchived:
		return m.Archived()
	case grocerylist.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroceryListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grocerylist.FieldName:
		return m.OldName(ctx)
	case grocerylist.FieldNote:
		return m.OldNote(ctx)
	case grocerylist.FieldArchived:
		return m.OldArchived(ctx)
	case grocerylist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GroceryList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroceryListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grocerylist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case grocerylist.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case grocerylist.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	case grocerylist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GroceryList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroceryListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroceryListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroceryListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroceryList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroceryListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroceryListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroceryListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GroceryList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroceryListMutation) ResetField(name string) error {
	switch name {
	case grocerylist.FieldName:
		m.ResetName()
		return nil
	case grocerylist.FieldNote:
		m.ResetNote()
		return nil
	case grocerylist.FieldArchived:
		m.ResetArchived()
		return nil
	case grocerylist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GroceryList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroceryListMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.grocery_list_items != nil {
		edges = append(edges, grocerylist.EdgeGroceryListItems)
	}
	if m.owner != nil {
		edges = append(edges, grocerylist.EdgeOwner)
	}
	if m.grocery_list_shares != nil {
		edges = append(edges, grocerylist.EdgeGroceryListShares)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroceryListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grocerylist.EdgeGroceryListItems:
		ids := make([]ent.Value, 0, len(m.grocery_list_items))
		for id := range m.grocery_list_items {
			ids = append(ids, id)
		}
		return ids
	case grocerylist.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case grocerylist.EdgeGroceryListShares:
		ids := make([]ent.Value, 0, len(m.grocery_list_shares))
		for id := range m.grocery_list_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroceryListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgrocery_list_items != nil {
		edges = append(edges, grocerylist.EdgeGroceryListItems)
	}
	if m.removedgrocery_list_shares != nil {
		edges = append(edges, grocerylist.EdgeGroceryListShares)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroceryListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case grocerylist.EdgeGroceryListItems:
		ids := make([]ent.Value, 0, len(m.removedgrocery_list_items))
		for id := range m.removedgrocery_list_items {
			ids = append(ids, id)
		}
		return ids
	case grocerylist.EdgeGroceryListShares:
		ids := make([]ent.Value, 0, len(m.removedgrocery_list_shares))
		for id := range m.removedgrocery_list_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroceryListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgrocery_list_items {
		edges = append(edges, grocerylist.EdgeGroceryListItems)
	}
	if m.clearedowner {
		edges = append(edges, grocerylist.EdgeOwner)
	}
	if m.clearedgrocery_list_shares {
		edges = append(edges, grocerylist.EdgeGroceryListShares)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroceryListMutation) EdgeCleared(name string) bool {
	switch name {
	case grocerylist.EdgeGroceryListItems:
		return m.clearedgrocery_list_items
	case grocerylist.EdgeOwner:
		return m.clearedowner
	case grocerylist.EdgeGroceryListShares:
		return m.clearedgrocery_list_shares
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroceryListMutation) ClearEdge(name string) error {
	switch name {
	case grocerylist.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown GroceryList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroceryListMutation) ResetEdge(name string) error {
	switch name {
	case grocerylist.EdgeGroceryListItems:
		m.ResetGroceryListItems()
		return nil
	case grocerylist.EdgeOwner:
		m.ResetOwner()
		return nil
	case grocerylist.EdgeGroceryListShares:
		m.ResetGroceryListShares()
		return nil
	}
	return fmt.Errorf("unknown GroceryList edge %s", name)
}

// GroceryListItemMutation represents an operation that mutates the GroceryListItem nodes in the graph.
type GroceryListItemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	quantity            *int
	addquantity         *int
	note                *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	grocery_list        *int
	clearedgrocery_list bool
	done                bool
	oldValue            func(context.Context) (*GroceryListItem, error)
	predicates          []predicate.GroceryListItem
}

var _ ent.Mutation = (*GroceryListItemMutation)(nil)

// grocerylistitemOption allows management of the mutation configuration using functional options.
type grocerylistitemOption func(*GroceryListItemMutation)

// newGroceryListItemMutation creates new mutation for the GroceryListItem entity.
func newGroceryListItemMutation(c config, op Op, opts ...grocerylistitemOption) *GroceryListItemMutation {
	m := &GroceryListItemMutation{
		config:        c,
		op:            op,
		typ:           TypeGroceryListItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroceryListItemID sets the ID field of the mutation.
func withGroceryListItemID(id int) grocerylistitemOption {
	return func(m *GroceryListItemMutation) {
		var (
			err   error
			once  sync.Once
			value *GroceryListItem
		)
		m.oldValue = func(ctx context.Context) (*GroceryListItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroceryListItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroceryListItem sets the old GroceryListItem of the mutation.
func withGroceryListItem(node *GroceryListItem) grocerylistitemOption {
	return func(m *GroceryListItemMutation) {
		m.oldValue = func(context.Context) (*GroceryListItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroceryListItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroceryListItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroceryListItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroceryListItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroceryListItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GroceryListItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroceryListItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GroceryListItem entity.
// If the GroceryListItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroceryListItemMutation) ResetName() {
	m.name = nil
}

// SetQuantity sets the "quantity" field.
func (m *GroceryListItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *GroceryListItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the GroceryListItem entity.
// If the GroceryListItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *GroceryListItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *GroceryListItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *GroceryListItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetNote sets the "note" field.
func (m *GroceryListItemMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *GroceryListItemMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the GroceryListItem entity.
// If the GroceryListItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListItemMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *GroceryListItemMutation) ResetNote() {
	m.note = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroceryListItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroceryListItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroceryListItem entity.
// If the GroceryListItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroceryListItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetGroceryListID sets the "grocery_list" edge to the GroceryList entity by id.
func (m *GroceryListItemMutation) SetGroceryListID(id int) {
	m.grocery_list = &id
}

// ClearGroceryList clears the "grocery_list" edge to the GroceryList entity.
func (m *GroceryListItemMutation) ClearGroceryList() {
	m.clearedgrocery_list = true
}

// GroceryListCleared reports if the "grocery_list" edge to the GroceryList entity was cleared.
func (m *GroceryListItemMutation) GroceryListCleared() bool {
	return m.clearedgrocery_list
}

// GroceryListID returns the "grocery_list" edge ID in the mutation.
func (m *GroceryListItemMutation) GroceryListID() (id int, exists bool) {
	if m.grocery_list != nil {
		return *m.grocery_list, true
	}
	return
}

// GroceryListIDs returns the "grocery_list" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroceryListID instead. It exists only for internal usage by the builders.
func (m *GroceryListItemMutation) GroceryListIDs() (ids []int) {
	if id := m.grocery_list; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroceryList resets all changes to the "grocery_list" edge.
func (m *GroceryListItemMutation) ResetGroceryList() {
	m.grocery_list = nil
	m.clearedgrocery_list = false
}

// Where appends a list predicates to the GroceryListItemMutation builder.
func (m *GroceryListItemMutation) Where(ps ...predicate.GroceryListItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroceryListItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroceryListItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroceryListItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroceryListItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroceryListItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroceryListItem).
func (m *GroceryListItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroceryListItemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, grocerylistitem.FieldName)
	}
	if m.quantity != nil {
		fields = append(fields, grocerylistitem.FieldQuantity)
	}
	if m.note != nil {
		fields = append(fields, grocerylistitem.FieldNote)
	}
	if m.created_at != nil {
		fields = append(fields, grocerylistitem.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroceryListItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grocerylistitem.FieldName:
		return m.Name()
	case grocerylistitem.FieldQuantity:
		return m.Quantity()
	case grocerylistitem.FieldNote:
		return m.Note()
	case grocerylistitem.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroceryListItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grocerylistitem.FieldName:
		return m.OldName(ctx)
	case grocerylistitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case grocerylistitem.FieldNote:
		return m.OldNote(ctx)
	case grocerylistitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GroceryListItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroceryListItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grocerylistitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case grocerylistitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case grocerylistitem.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case grocerylistitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GroceryListItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroceryListItemMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, grocerylistitem.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroceryListItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case grocerylistitem.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroceryListItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case grocerylistitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown GroceryListItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroceryListItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroceryListItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroceryListItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GroceryListItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroceryListItemMutation) ResetField(name string) error {
	switch name {
	case grocerylistitem.FieldName:
		m.ResetName()
		return nil
	case grocerylistitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case grocerylistitem.FieldNote:
		m.ResetNote()
		return nil
	case grocerylistitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GroceryListItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroceryListItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.grocery_list != nil {
		edges = append(edges, grocerylistitem.EdgeGroceryList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroceryListItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grocerylistitem.EdgeGroceryList:
		if id := m.grocery_list; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroceryListItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroceryListItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroceryListItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgrocery_list {
		edges = append(edges, grocerylistitem.EdgeGroceryList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroceryListItemMutation) EdgeCleared(name string) bool {
	switch name {
	case grocerylistitem.EdgeGroceryList:
		return m.clearedgrocery_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroceryListItemMutation) ClearEdge(name string) error {
	switch name {
	case grocerylistitem.EdgeGroceryList:
		m.ClearGroceryList()
		return nil
	}
	return fmt.Errorf("unknown GroceryListItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroceryListItemMutation) ResetEdge(name string) error {
	switch name {
	case grocerylistitem.EdgeGroceryList:
		m.ResetGroceryList()
		return nil
	}
	return fmt.Errorf("unknown GroceryListItem edge %s", name)
}

// GroceryListShareMutation represents an operation that mutates the GroceryListShare nodes in the graph.
type GroceryListShareMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	can_edit            *bool
	created_at          *time.Time
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	grocery_list        *int
	clearedgrocery_list bool
	done                bool
	oldValue            func(context.Context) (*GroceryListShare, error)
	predicates          []predicate.GroceryListShare
}

var _ ent.Mutation = (*GroceryListShareMutation)(nil)

// grocerylistshareOption allows management of the mutation configuration using functional options.
type grocerylistshareOption func(*GroceryListShareMutation)

// newGroceryListShareMutation creates new mutation for the GroceryListShare entity.
func newGroceryListShareMutation(c config, op Op, opts ...grocerylistshareOption) *GroceryListShareMutation {
	m := &GroceryListShareMutation{
		config:        c,
		op:            op,
		typ:           TypeGroceryListShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroceryListShareID sets the ID field of the mutation.
func withGroceryListShareID(id int) grocerylistshareOption {
	return func(m *GroceryListShareMutation) {
		var (
			err   error
			once  sync.Once
			value *GroceryListShare
		)
		m.oldValue = func(ctx context.Context) (*GroceryListShare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroceryListShare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroceryListShare sets the old GroceryListShare of the mutation.
func withGroceryListShare(node *GroceryListShare) grocerylistshareOption {
	return func(m *GroceryListShareMutation) {
		m.oldValue = func(context.Context) (*GroceryListShare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroceryListShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroceryListShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroceryListShareMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroceryListShareMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroceryListShare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCanEdit sets the "can_edit" field.
func (m *GroceryListShareMutation) SetCanEdit(b bool) {
	m.can_edit = &b
}

// CanEdit returns the value of the "can_edit" field in the mutation.
func (m *GroceryListShareMutation) CanEdit() (r bool, exists bool) {
	v := m.can_edit
	if v == nil {
		return
	}
	return *v, true
}

// OldCanEdit returns the old "can_edit" field's value of the GroceryListShare entity.
// If the GroceryListShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListShareMutation) OldCanEdit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanEdit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanEdit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanEdit: %w", err)
	}
	return oldValue.CanEdit, nil
}

// ResetCanEdit resets all changes to the "can_edit" field.
func (m *GroceryListShareMutation) ResetCanEdit() {
	m.can_edit = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroceryListShareMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroceryListShareMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroceryListShare entity.
// If the GroceryListShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroceryListShareMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroceryListShareMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *GroceryListShareMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *GroceryListShareMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *GroceryListShareMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *GroceryListShareMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *GroceryListShareMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *GroceryListShareMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetGroceryListID sets the "grocery_list" edge to the GroceryList entity by id.
func (m *GroceryListShareMutation) SetGroceryListID(id int) {
	m.grocery_list = &id
}

// ClearGroceryList clears the "grocery_list" edge to the GroceryList entity.
func (m *GroceryListShareMutation) ClearGroceryList() {
	m.clearedgrocery_list = true
}

// GroceryListCleared reports if the "grocery_list" edge to the GroceryList entity was cleared.
func (m *GroceryListShareMutation) GroceryListCleared() bool {
	return m.clearedgrocery_list
}

// GroceryListID returns the "grocery_list" edge ID in the mutation.
func (m *GroceryListShareMutation) GroceryListID() (id int, exists bool) {
	if m.grocery_list != nil {
		return *m.grocery_list, true
	}
	return
}

// GroceryListIDs returns the "grocery_list" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroceryListID instead. It exists only for internal usage by the builders.
func (m *GroceryListShareMutation) GroceryListIDs() (ids []int) {
	if id := m.grocery_list; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroceryList resets all changes to the "grocery_list" edge.
func (m *GroceryListShareMutation) ResetGroceryList() {
	m.grocery_list = nil
	m.clearedgrocery_list = false
}

// Where appends a list predicates to the GroceryListShareMutation builder.
func (m *GroceryListShareMutation) Where(ps ...predicate.GroceryListShare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroceryListShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroceryListShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroceryListShare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroceryListShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroceryListShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroceryListShare).
func (m *GroceryListShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroceryListShareMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.can_edit != nil {
		fields = append(fields, grocerylistshare.FieldCanEdit)
	}
	if m.created_at != nil {
		fields = append(fields, grocerylistshare.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroceryListShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grocerylistshare.FieldCanEdit:
		return m.CanEdit()
	case grocerylistshare.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroceryListShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grocerylistshare.FieldCanEdit:
		return m.OldCanEdit(ctx)
	case grocerylistshare.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GroceryListShare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroceryListShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grocerylistshare.FieldCanEdit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanEdit(v)
		return nil
	case grocerylistshare.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GroceryListShare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroceryListShareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroceryListShareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroceryListShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroceryListShare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroceryListShareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroceryListShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroceryListShareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GroceryListShare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroceryListShareMutation) ResetField(name string) error {
	switch name {
	case grocerylistshare.FieldCanEdit:
		m.ResetCanEdit()
		return nil
	case grocerylistshare.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GroceryListShare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroceryListShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, grocerylistshare.EdgeUser)
	}
	if m.grocery_list != nil {
		edges = append(edges, grocerylistshare.EdgeGroceryList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroceryListShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grocerylistshare.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case grocerylistshare.EdgeGroceryList:
		if id := m.grocery_list; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroceryListShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroceryListShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroceryListShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, grocerylistshare.EdgeUser)
	}
	if m.clearedgrocery_list {
		edges = append(edges, grocerylistshare.EdgeGroceryList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroceryListShareMutation) EdgeCleared(name string) bool {
	switch name {
	case grocerylistshare.EdgeUser:
		return m.cleareduser
	case grocerylistshare.EdgeGroceryList:
		return m.clearedgrocery_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroceryListShareMutation) ClearEdge(name string) error {
	switch name {
	case grocerylistshare.EdgeUser:
		m.ClearUser()
		return nil
	case grocerylistshare.EdgeGroceryList:
		m.ClearGroceryList()
		return nil
	}
	return fmt.Errorf("unknown GroceryListShare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroceryListShareMutation) ResetEdge(name string) error {
	switch name {
	case grocerylistshare.EdgeUser:
		m.ResetUser()
		return nil
	case grocerylistshare.EdgeGroceryList:
		m.ResetGroceryList()
		return nil
	}
	return fmt.Errorf("unknown GroceryListShare edge %s", name)
}

// MovieMutation represents an operation that mutates the Movie nodes in the graph.
type MovieMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	note              *string
	watched           *bool
	created_at        *time.Time
	clearedFields     map[string]struct{}
	movie_list        *int
	clearedmovie_list bool
	done              bool
	oldValue          func(context.Context) (*Movie, error)
	predicates        []predicate.Movie
}

var _ ent.Mutation = (*MovieMutation)(nil)

// movieOption allows management of the mutation configuration using functional options.
type movieOption func(*MovieMutation)

// newMovieMutation creates new mutation for the Movie entity.
func newMovieMutation(c config, op Op, opts ...movieOption) *MovieMutation {
	m := &MovieMutation{
		config:        c,
		op:            op,
		typ:           TypeMovie,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMovieID sets the ID field of the mutation.
func withMovieID(id int) movieOption {
	return func(m *MovieMutation) {
		var (
			err   error
			once  sync.Once
			value *Movie
		)
		m.oldValue = func(ctx context.Context) (*Movie, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Movie.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMovie sets the old Movie of the mutation.
func withMovie(node *Movie) movieOption {
	return func(m *MovieMutation) {
		m.oldValue = func(context.Context) (*Movie, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MovieMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MovieMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MovieMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MovieMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Movie.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MovieMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MovieMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MovieMutation) ResetName() {
	m.name = nil
}

// SetNote sets the "note" field.
func (m *MovieMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *MovieMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *MovieMutation) ResetNote() {
	m.note = nil
}

// SetWatched sets the "watched" field.
func (m *MovieMutation) SetWatched(b bool) {
	m.watched = &b
}

// Watched returns the value of the "watched" field in the mutation.
func (m *MovieMutation) Watched() (r bool, exists bool) {
	v := m.watched
	if v == nil {
		return
	}
	return *v, true
}

// OldWatched returns the old "watched" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldWatched(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWatched is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWatched requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatched: %w", err)
	}
	return oldValue.Watched, nil
}

// ResetWatched resets all changes to the "watched" field.
func (m *MovieMutation) ResetWatched() {
	m.watched = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MovieMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MovieMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Movie entity.
// If the Movie object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MovieMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMovieListID sets the "movie_list" edge to the MovieList entity by id.
func (m *MovieMutation) SetMovieListID(id int) {
	m.movie_list = &id
}

// ClearMovieList clears the "movie_list" edge to the MovieList entity.
func (m *MovieMutation) ClearMovieList() {
	m.clearedmovie_list = true
}

// MovieListCleared reports if the "movie_list" edge to the MovieList entity was cleared.
func (m *MovieMutation) MovieListCleared() bool {
	return m.clearedmovie_list
}

// MovieListID returns the "movie_list" edge ID in the mutation.
func (m *MovieMutation) MovieListID() (id int, exists bool) {
	if m.movie_list != nil {
		return *m.movie_list, true
	}
	return
}

// MovieListIDs returns the "movie_list" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MovieListID instead. It exists only for internal usage by the builders.
func (m *MovieMutation) MovieListIDs() (ids []int) {
	if id := m.movie_list; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMovieList resets all changes to the "movie_list" edge.
func (m *MovieMutation) ResetMovieList() {
	m.movie_list = nil
	m.clearedmovie_list = false
}

// Where appends a list predicates to the MovieMutation builder.
func (m *MovieMutation) Where(ps ...predicate.Movie) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MovieMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MovieMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Movie, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MovieMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MovieMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Movie).
func (m *MovieMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MovieMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, movie.FieldName)
	}
	if m.note != nil {
		fields = append(fields, movie.FieldNote)
	}
	if m.watched != nil {
		fields = append(fields, movie.FieldWatched)
	}
	if m.created_at != nil {
		fields = append(fields, movie.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MovieMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case movie.FieldName:
		return m.Name()
	case movie.FieldNote:
		return m.Note()
	case movie.FieldWatched:
		return m.Watched()
	case movie.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MovieMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case movie.FieldName:
		return m.OldName(ctx)
	case movie.FieldNote:
		return m.OldNote(ctx)
	case movie.FieldWatched:
		return m.OldWatched(ctx)
	case movie.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Movie field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieMutation) SetField(name string, value ent.Value) error {
	switch name {
	case movie.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case movie.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case movie.FieldWatched:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatched(v)
		return nil
	case movie.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Movie field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MovieMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MovieMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Movie numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MovieMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MovieMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MovieMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Movie nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MovieMutation) ResetField(name string) error {
	switch name {
	case movie.FieldName:
		m.ResetName()
		return nil
	case movie.FieldNote:
		m.ResetNote()
		return nil
	case movie.FieldWatched:
		m.ResetWatched()
		return nil
	case movie.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Movie field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MovieMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.movie_list != nil {
		edges = append(edges, movie.EdgeMovieList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MovieMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case movie.EdgeMovieList:
		if id := m.movie_list; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MovieMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MovieMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MovieMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmovie_list {
		edges = append(edges, movie.EdgeMovieList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MovieMutation) EdgeCleared(name string) bool {
	switch name {
	case movie.EdgeMovieList:
		return m.clearedmovie_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MovieMutation) ClearEdge(name string) error {
	switch name {
	case movie.EdgeMovieList:
		m.ClearMovieList()
		return nil
	}
	return fmt.Errorf("unknown Movie unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MovieMutation) ResetEdge(name string) error {
	switch name {
	case movie.EdgeMovieList:
		m.ResetMovieList()
		return nil
	}
	return fmt.Errorf("unknown Movie edge %s", name)
}

// MovieListMutation represents an operation that mutates the MovieList nodes in the graph.
type MovieListMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	note                     *string
	show_watched             *bool
	created_at               *time.Time
	clearedFields            map[string]struct{}
	movies                   map[int]struct{}
	removedmovies            map[int]struct{}
	clearedmovies            bool
	owner                    *int
	clearedowner             bool
	movie_list_shares        map[int]struct{}
	removedmovie_list_shares map[int]struct{}
	clearedmovie_list_shares bool
	done                     bool
	oldValue                 func(context.Context) (*MovieList, error)
	predicates               []predicate.MovieList
}

var _ ent.Mutation = (*MovieListMutation)(nil)

// movielistOption allows management of the mutation configuration using functional options.
type movielistOption func(*MovieListMutation)

// newMovieListMutation creates new mutation for the MovieList entity.
func newMovieListMutation(c config, op Op, opts ...movielistOption) *MovieListMutation {
	m := &MovieListMutation{
		config:        c,
		op:            op,
		typ:           TypeMovieList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMovieListID sets the ID field of the mutation.
func withMovieListID(id int) movielistOption {
	return func(m *MovieListMutation) {
		var (
			err   error
			once  sync.Once
			value *MovieList
		)
		m.oldValue = func(ctx context.Context) (*MovieList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MovieList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMovieList sets the old MovieList of the mutation.
func withMovieList(node *MovieList) movielistOption {
	return func(m *MovieListMutation) {
		m.oldValue = func(context.Context) (*MovieList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MovieListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MovieListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MovieListMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MovieListMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MovieList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MovieListMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MovieListMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MovieList entity.
// If the MovieList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieListMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MovieListMutation) ResetName() {
	m.name = nil
}

// SetNote sets the "note" field.
func (m *MovieListMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *MovieListMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the MovieList entity.
// If the MovieList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieListMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *MovieListMutation) ResetNote() {
	m.note = nil
}

// SetShowWatched sets the "show_watched" field.
func (m *MovieListMutation) SetShowWatched(b bool) {
	m.show_watched = &b
}

// ShowWatched returns the value of the "show_watched" field in the mutation.
func (m *MovieListMutation) ShowWatched() (r bool, exists bool) {
	v := m.show_watched
	if v == nil {
		return
	}
	return *v, true
}

// OldShowWatched returns the old "show_watched" field's value of the MovieList entity.
// If the MovieList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieListMutation) OldShowWatched(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowWatched is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowWatched requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowWatched: %w", err)
	}
	return oldValue.ShowWatched, nil
}

// ResetShowWatched resets all changes to the "show_watched" field.
func (m *MovieListMutation) ResetShowWatched() {
	m.show_watched = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MovieListMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MovieListMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MovieList entity.
// If the MovieList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieListMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MovieListMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddMovieIDs adds the "movies" edge to the Movie entity by ids.
func (m *MovieListMutation) AddMovieIDs(ids ...int) {
	if m.movies == nil {
		m.movies = make(map[int]struct{})
	}
	for i := range ids {
		m.movies[ids[i]] = struct{}{}
	}
}

// ClearMovies clears the "movies" edge to the Movie entity.
func (m *MovieListMutation) ClearMovies() {
	m.clearedmovies = true
}

// MoviesCleared reports if the "movies" edge to the Movie entity was cleared.
func (m *MovieListMutation) MoviesCleared() bool {
	return m.clearedmovies
}

// RemoveMovieIDs removes the "movies" edge to the Movie entity by IDs.
func (m *MovieListMutation) RemoveMovieIDs(ids ...int) {
	if m.removedmovies == nil {
		m.removedmovies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movies, ids[i])
		m.removedmovies[ids[i]] = struct{}{}
	}
}

// RemovedMovies returns the removed IDs of the "movies" edge to the Movie entity.
func (m *MovieListMutation) RemovedMoviesIDs() (ids []int) {
	for id := range m.removedmovies {
		ids = append(ids, id)
	}
	return
}

// MoviesIDs returns the "movies" edge IDs in the mutation.
func (m *MovieListMutation) MoviesIDs() (ids []int) {
	for id := range m.movies {
		ids = append(ids, id)
	}
	return
}

// ResetMovies resets all changes to the "movies" edge.
func (m *MovieListMutation) ResetMovies() {
	m.movies = nil
	m.clearedmovies = false
	m.removedmovies = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *MovieListMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *MovieListMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *MovieListMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MovieListMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MovieListMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MovieListMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddMovieListShareIDs adds the "movie_list_shares" edge to the MovieListShare entity by ids.
func (m *MovieListMutation) AddMovieListShareIDs(ids ...int) {
	if m.movie_list_shares == nil {
		m.movie_list_shares = make(map[int]struct{})
	}
	for i := range ids {
		m.movie_list_shares[ids[i]] = struct{}{}
	}
}

// ClearMovieListShares clears the "movie_list_shares" edge to the MovieListShare entity.
func (m *MovieListMutation) ClearMovieListShares() {
	m.clearedmovie_list_shares = true
}

// MovieListSharesCleared reports if the "movie_list_shares" edge to the MovieListShare entity was cleared.
func (m *MovieListMutation) MovieListSharesCleared() bool {
	return m.clearedmovie_list_shares
}

// RemoveMovieListShareIDs removes the "movie_list_shares" edge to the MovieListShare entity by IDs.
func (m *MovieListMutation) RemoveMovieListShareIDs(ids ...int) {
	if m.removedmovie_list_shares == nil {
		m.removedmovie_list_shares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movie_list_shares, ids[i])
		m.removedmovie_list_shares[ids[i]] = struct{}{}
	}
}

// RemovedMovieListShares returns the removed IDs of the "movie_list_shares" edge to the MovieListShare entity.
func (m *MovieListMutation) RemovedMovieListSharesIDs() (ids []int) {
	for id := range m.removedmovie_list_shares {
		ids = append(ids, id)
	}
	return
}

// MovieListSharesIDs returns the "movie_list_shares" edge IDs in the mutation.
func (m *MovieListMutation) MovieListSharesIDs() (ids []int) {
	for id := range m.movie_list_shares {
		ids = append(ids, id)
	}
	return
}

// ResetMovieListShares resets all changes to the "movie_list_shares" edge.
func (m *MovieListMutation) ResetMovieListShares() {
	m.movie_list_shares = nil
	m.clearedmovie_list_shares = false
	m.removedmovie_list_shares = nil
}

// Where appends a list predicates to the MovieListMutation builder.
func (m *MovieListMutation) Where(ps ...predicate.MovieList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MovieListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MovieListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MovieList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MovieListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MovieListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MovieList).
func (m *MovieListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MovieListMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, movielist.FieldName)
	}
	if m.note != nil {
		fields = append(fields, movielist.FieldNote)
	}
	if m.show_watched != nil {
		fields = append(fields, movielist.FieldShowWatched)
	}
	if m.created_at != nil {
		fields = append(fields, movielist.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MovieListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case movielist.FieldName:
		return m.Name()
	case movielist.FieldNote:
		return m.Note()
	case movielist.FieldShowWatched:
		return m.ShowWatched()
	case movielist.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MovieListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case movielist.FieldName:
		return m.OldName(ctx)
	case movielist.FieldNote:
		return m.OldNote(ctx)
	case movielist.FieldShowWatched:
		return m.OldShowWatched(ctx)
	case movielist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MovieList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case movielist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case movielist.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case movielist.FieldShowWatched:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowWatched(v)
		return nil
	case movielist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MovieList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MovieListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MovieListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MovieList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MovieListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MovieListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MovieListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MovieList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MovieListMutation) ResetField(name string) error {
	switch name {
	case movielist.FieldName:
		m.ResetName()
		return nil
	case movielist.FieldNote:
		m.ResetNote()
		return nil
	case movielist.FieldShowWatched:
		m.ResetShowWatched()
		return nil
	case movielist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MovieList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MovieListMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.movies != nil {
		edges = append(edges, movielist.EdgeMovies)
	}
	if m.owner != nil {
		edges = append(edges, movielist.EdgeOwner)
	}
	if m.movie_list_shares != nil {
		edges = append(edges, movielist.EdgeMovieListShares)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MovieListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case movielist.EdgeMovies:
		ids := make([]ent.Value, 0, len(m.movies))
		for id := range m.movies {
			ids = append(ids, id)
		}
		return ids
	case movielist.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case movielist.EdgeMovieListShares:
		ids := make([]ent.Value, 0, len(m.movie_list_shares))
		for id := range m.movie_list_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MovieListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmovies != nil {
		edges = append(edges, movielist.EdgeMovies)
	}
	if m.removedmovie_list_shares != nil {
		edges = append(edges, movielist.EdgeMovieListShares)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MovieListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case movielist.EdgeMovies:
		ids := make([]ent.Value, 0, len(m.removedmovies))
		for id := range m.removedmovies {
			ids = append(ids, id)
		}
		return ids
	case movielist.EdgeMovieListShares:
		ids := make([]ent.Value, 0, len(m.removedmovie_list_shares))
		for id := range m.removedmovie_list_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MovieListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmovies {
		edges = append(edges, movielist.EdgeMovies)
	}
	if m.clearedowner {
		edges = append(edges, movielist.EdgeOwner)
	}
	if m.clearedmovie_list_shares {
		edges = append(edges, movielist.EdgeMovieListShares)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MovieListMutation) EdgeCleared(name string) bool {
	switch name {
	case movielist.EdgeMovies:
		return m.clearedmovies
	case movielist.EdgeOwner:
		return m.clearedowner
	case movielist.EdgeMovieListShares:
		return m.clearedmovie_list_shares
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MovieListMutation) ClearEdge(name string) error {
	switch name {
	case movielist.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown MovieList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MovieListMutation) ResetEdge(name string) error {
	switch name {
	case movielist.EdgeMovies:
		m.ResetMovies()
		return nil
	case movielist.EdgeOwner:
		m.ResetOwner()
		return nil
	case movielist.EdgeMovieListShares:
		m.ResetMovieListShares()
		return nil
	}
	return fmt.Errorf("unknown MovieList edge %s", name)
}

// MovieListShareMutation represents an operation that mutates the MovieListShare nodes in the graph.
type MovieListShareMutation struct {
	config
	op                Op
	typ               string
	id                *int
	can_edit          *bool
	created_at        *time.Time
	clearedFields     map[string]struct{}
	user              *int
	cleareduser       bool
	movie_list        *int
	clearedmovie_list bool
	done              bool
	oldValue          func(context.Context) (*MovieListShare, error)
	predicates        []predicate.MovieListShare
}

var _ ent.Mutation = (*MovieListShareMutation)(nil)

// movielistshareOption allows management of the mutation configuration using functional options.
type movielistshareOption func(*MovieListShareMutation)

// newMovieListShareMutation creates new mutation for the MovieListShare entity.
func newMovieListShareMutation(c config, op Op, opts ...movielistshareOption) *MovieListShareMutation {
	m := &MovieListShareMutation{
		config:        c,
		op:            op,
		typ:           TypeMovieListShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMovieListShareID sets the ID field of the mutation.
func withMovieListShareID(id int) movielistshareOption {
	return func(m *MovieListShareMutation) {
		var (
			err   error
			once  sync.Once
			value *MovieListShare
		)
		m.oldValue = func(ctx context.Context) (*MovieListShare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MovieListShare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMovieListShare sets the old MovieListShare of the mutation.
func withMovieListShare(node *MovieListShare) movielistshareOption {
	return func(m *MovieListShareMutation) {
		m.oldValue = func(context.Context) (*MovieListShare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MovieListShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MovieListShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MovieListShareMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MovieListShareMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MovieListShare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCanEdit sets the "can_edit" field.
func (m *MovieListShareMutation) SetCanEdit(b bool) {
	m.can_edit = &b
}

// CanEdit returns the value of the "can_edit" field in the mutation.
func (m *MovieListShareMutation) CanEdit() (r bool, exists bool) {
	v := m.can_edit
	if v == nil {
		return
	}
	return *v, true
}

// OldCanEdit returns the old "can_edit" field's value of the MovieListShare entity.
// If the MovieListShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieListShareMutation) OldCanEdit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanEdit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanEdit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanEdit: %w", err)
	}
	return oldValue.CanEdit, nil
}

// ResetCanEdit resets all changes to the "can_edit" field.
func (m *MovieListShareMutation) ResetCanEdit() {
	m.can_edit = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MovieListShareMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MovieListShareMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MovieListShare entity.
// If the MovieListShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MovieListShareMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MovieListShareMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MovieListShareMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MovieListShareMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MovieListShareMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MovieListShareMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MovieListShareMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MovieListShareMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetMovieListID sets the "movie_list" edge to the MovieList entity by id.
func (m *MovieListShareMutation) SetMovieListID(id int) {
	m.movie_list = &id
}

// ClearMovieList clears the "movie_list" edge to the MovieList entity.
func (m *MovieListShareMutation) ClearMovieList() {
	m.clearedmovie_list = true
}

// MovieListCleared reports if the "movie_list" edge to the MovieList entity was cleared.
func (m *MovieListShareMutation) MovieListCleared() bool {
	return m.clearedmovie_list
}

// MovieListID returns the "movie_list" edge ID in the mutation.
func (m *MovieListShareMutation) MovieListID() (id int, exists bool) {
	if m.movie_list != nil {
		return *m.movie_list, true
	}
	return
}

// MovieListIDs returns the "movie_list" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MovieListID instead. It exists only for internal usage by the builders.
func (m *MovieListShareMutation) MovieListIDs() (ids []int) {
	if id := m.movie_list; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMovieList resets all changes to the "movie_list" edge.
func (m *MovieListShareMutation) ResetMovieList() {
	m.movie_list = nil
	m.clearedmovie_list = false
}

// Where appends a list predicates to the MovieListShareMutation builder.
func (m *MovieListShareMutation) Where(ps ...predicate.MovieListShare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MovieListShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MovieListShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MovieListShare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MovieListShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MovieListShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MovieListShare).
func (m *MovieListShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MovieListShareMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.can_edit != nil {
		fields = append(fields, movielistshare.FieldCanEdit)
	}
	if m.created_at != nil {
		fields = append(fields, movielistshare.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MovieListShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case movielistshare.FieldCanEdit:
		return m.CanEdit()
	case movielistshare.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MovieListShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case movielistshare.FieldCanEdit:
		return m.OldCanEdit(ctx)
	case movielistshare.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MovieListShare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieListShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case movielistshare.FieldCanEdit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanEdit(v)
		return nil
	case movielistshare.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MovieListShare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MovieListShareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MovieListShareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MovieListShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MovieListShare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MovieListShareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MovieListShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MovieListShareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MovieListShare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MovieListShareMutation) ResetField(name string) error {
	switch name {
	case movielistshare.FieldCanEdit:
		m.ResetCanEdit()
		return nil
	case movielistshare.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MovieListShare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MovieListShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, movielistshare.EdgeUser)
	}
	if m.movie_list != nil {
		edges = append(edges, movielistshare.EdgeMovieList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MovieListShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case movielistshare.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case movielistshare.EdgeMovieList:
		if id := m.movie_list; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MovieListShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MovieListShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MovieListShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, movielistshare.EdgeUser)
	}
	if m.clearedmovie_list {
		edges = append(edges, movielistshare.EdgeMovieList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MovieListShareMutation) EdgeCleared(name string) bool {
	switch name {
	case movielistshare.EdgeUser:
		return m.cleareduser
	case movielistshare.EdgeMovieList:
		return m.clearedmovie_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MovieListShareMutation) ClearEdge(name string) error {
	switch name {
	case movielistshare.EdgeUser:
		m.ClearUser()
		return nil
	case movielistshare.EdgeMovieList:
		m.ClearMovieList()
		return nil
	}
	return fmt.Errorf("unknown MovieListShare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MovieListShareMutation) ResetEdge(name string) error {
	switch name {
	case movielistshare.EdgeUser:
		m.ResetUser()
		return nil
	case movielistshare.EdgeMovieList:
		m.ResetMovieList()
		return nil
	}
	return fmt.Errorf("unknown MovieListShare edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	display_name               *string
	name_changes               *int8
	addname_changes            *int8
	email                      *string
	verified                   *bool
	locked                     *bool
	last_login                 *time.Time
	created_at                 *time.Time
	clearedFields              map[string]struct{}
	amazon_shares              map[int]struct{}
	removedamazon_shares       map[int]struct{}
	clearedamazon_shares       bool
	amazon_lists               map[int]struct{}
	removedamazon_lists        map[int]struct{}
	clearedamazon_lists        bool
	drinks                     map[int]struct{}
	removeddrinks              map[int]struct{}
	cleareddrinks              bool
	grocery_lists              map[int]struct{}
	removedgrocery_lists       map[int]struct{}
	clearedgrocery_lists       bool
	grocery_list_shares        map[int]struct{}
	removedgrocery_list_shares map[int]struct{}
	clearedgrocery_list_shares bool
	movie_lists                map[int]struct{}
	removedmovie_lists         map[int]struct{}
	clearedmovie_lists         bool
	movie_list_shares          map[int]struct{}
	removedmovie_list_shares   map[int]struct{}
	clearedmovie_list_shares   bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetNameChanges sets the "name_changes" field.
func (m *UserMutation) SetNameChanges(i int8) {
	m.name_changes = &i
	m.addname_changes = nil
}

// NameChanges returns the value of the "name_changes" field in the mutation.
func (m *UserMutation) NameChanges() (r int8, exists bool) {
	v := m.name_changes
	if v == nil {
		return
	}
	return *v, true
}

// OldNameChanges returns the old "name_changes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNameChanges(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameChanges: %w", err)
	}
	return oldValue.NameChanges, nil
}

// AddNameChanges adds i to the "name_changes" field.
func (m *UserMutation) AddNameChanges(i int8) {
	if m.addname_changes != nil {
		*m.addname_changes += i
	} else {
		m.addname_changes = &i
	}
}

// AddedNameChanges returns the value that was added to the "name_changes" field in this mutation.
func (m *UserMutation) AddedNameChanges() (r int8, exists bool) {
	v := m.addname_changes
	if v == nil {
		return
	}
	return *v, true
}

// ResetNameChanges resets all changes to the "name_changes" field.
func (m *UserMutation) ResetNameChanges() {
	m.name_changes = nil
	m.addname_changes = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetVerified sets the "verified" field.
func (m *UserMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *UserMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *UserMutation) ResetVerified() {
	m.verified = nil
}

// SetLocked sets the "locked" field.
func (m *UserMutation) SetLocked(b bool) {
	m.locked = &b
}

// Locked returns the value of the "locked" field in the mutation.
func (m *UserMutation) Locked() (r bool, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ResetLocked resets all changes to the "locked" field.
func (m *UserMutation) ResetLocked() {
	m.locked = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddAmazonShareIDs adds the "amazon_shares" edge to the AmazonShare entity by ids.
func (m *UserMutation) AddAmazonShareIDs(ids ...int) {
	if m.amazon_shares == nil {
		m.amazon_shares = make(map[int]struct{})
	}
	for i := range ids {
		m.amazon_shares[ids[i]] = struct{}{}
	}
}

// ClearAmazonShares clears the "amazon_shares" edge to the AmazonShare entity.
func (m *UserMutation) ClearAmazonShares() {
	m.clearedamazon_shares = true
}

// AmazonSharesCleared reports if the "amazon_shares" edge to the AmazonShare entity was cleared.
func (m *UserMutation) AmazonSharesCleared() bool {
	return m.clearedamazon_shares
}

// RemoveAmazonShareIDs removes the "amazon_shares" edge to the AmazonShare entity by IDs.
func (m *UserMutation) RemoveAmazonShareIDs(ids ...int) {
	if m.removedamazon_shares == nil {
		m.removedamazon_shares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.amazon_shares, ids[i])
		m.removedamazon_shares[ids[i]] = struct{}{}
	}
}

// RemovedAmazonShares returns the removed IDs of the "amazon_shares" edge to the AmazonShare entity.
func (m *UserMutation) RemovedAmazonSharesIDs() (ids []int) {
	for id := range m.removedamazon_shares {
		ids = append(ids, id)
	}
	return
}

// AmazonSharesIDs returns the "amazon_shares" edge IDs in the mutation.
func (m *UserMutation) AmazonSharesIDs() (ids []int) {
	for id := range m.amazon_shares {
		ids = append(ids, id)
	}
	return
}

// ResetAmazonShares resets all changes to the "amazon_shares" edge.
func (m *UserMutation) ResetAmazonShares() {
	m.amazon_shares = nil
	m.clearedamazon_shares = false
	m.removedamazon_shares = nil
}

// AddAmazonListIDs adds the "amazon_lists" edge to the AmazonList entity by ids.
func (m *UserMutation) AddAmazonListIDs(ids ...int) {
	if m.amazon_lists == nil {
		m.amazon_lists = make(map[int]struct{})
	}
	for i := range ids {
		m.amazon_lists[ids[i]] = struct{}{}
	}
}

// ClearAmazonLists clears the "amazon_lists" edge to the AmazonList entity.
func (m *UserMutation) ClearAmazonLists() {
	m.clearedamazon_lists = true
}

// AmazonListsCleared reports if the "amazon_lists" edge to the AmazonList entity was cleared.
func (m *UserMutation) AmazonListsCleared() bool {
	return m.clearedamazon_lists
}

// RemoveAmazonListIDs removes the "amazon_lists" edge to the AmazonList entity by IDs.
func (m *UserMutation) RemoveAmazonListIDs(ids ...int) {
	if m.removedamazon_lists == nil {
		m.removedamazon_lists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.amazon_lists, ids[i])
		m.removedamazon_lists[ids[i]] = struct{}{}
	}
}

// RemovedAmazonLists returns the removed IDs of the "amazon_lists" edge to the AmazonList entity.
func (m *UserMutation) RemovedAmazonListsIDs() (ids []int) {
	for id := range m.removedamazon_lists {
		ids = append(ids, id)
	}
	return
}

// AmazonListsIDs returns the "amazon_lists" edge IDs in the mutation.
func (m *UserMutation) AmazonListsIDs() (ids []int) {
	for id := range m.amazon_lists {
		ids = append(ids, id)
	}
	return
}

// ResetAmazonLists resets all changes to the "amazon_lists" edge.
func (m *UserMutation) ResetAmazonLists() {
	m.amazon_lists = nil
	m.clearedamazon_lists = false
	m.removedamazon_lists = nil
}

// AddDrinkIDs adds the "drinks" edge to the Drink entity by ids.
func (m *UserMutation) AddDrinkIDs(ids ...int) {
	if m.drinks == nil {
		m.drinks = make(map[int]struct{})
	}
	for i := range ids {
		m.drinks[ids[i]] = struct{}{}
	}
}

// ClearDrinks clears the "drinks" edge to the Drink entity.
func (m *UserMutation) ClearDrinks() {
	m.cleareddrinks = true
}

// DrinksCleared reports if the "drinks" edge to the Drink entity was cleared.
func (m *UserMutation) DrinksCleared() bool {
	return m.cleareddrinks
}

// RemoveDrinkIDs removes the "drinks" edge to the Drink entity by IDs.
func (m *UserMutation) RemoveDrinkIDs(ids ...int) {
	if m.removeddrinks == nil {
		m.removeddrinks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.drinks, ids[i])
		m.removeddrinks[ids[i]] = struct{}{}
	}
}

// RemovedDrinks returns the removed IDs of the "drinks" edge to the Drink entity.
func (m *UserMutation) RemovedDrinksIDs() (ids []int) {
	for id := range m.removeddrinks {
		ids = append(ids, id)
	}
	return
}

// DrinksIDs returns the "drinks" edge IDs in the mutation.
func (m *UserMutation) DrinksIDs() (ids []int) {
	for id := range m.drinks {
		ids = append(ids, id)
	}
	return
}

// ResetDrinks resets all changes to the "drinks" edge.
func (m *UserMutation) ResetDrinks() {
	m.drinks = nil
	m.cleareddrinks = false
	m.removeddrinks = nil
}

// AddGroceryListIDs adds the "grocery_lists" edge to the GroceryList entity by ids.
func (m *UserMutation) AddGroceryListIDs(ids ...int) {
	if m.grocery_lists == nil {
		m.grocery_lists = make(map[int]struct{})
	}
	for i := range ids {
		m.grocery_lists[ids[i]] = struct{}{}
	}
}

// ClearGroceryLists clears the "grocery_lists" edge to the GroceryList entity.
func (m *UserMutation) ClearGroceryLists() {
	m.clearedgrocery_lists = true
}

// GroceryListsCleared reports if the "grocery_lists" edge to the GroceryList entity was cleared.
func (m *UserMutation) GroceryListsCleared() bool {
	return m.clearedgrocery_lists
}

// RemoveGroceryListIDs removes the "grocery_lists" edge to the GroceryList entity by IDs.
func (m *UserMutation) RemoveGroceryListIDs(ids ...int) {
	if m.removedgrocery_lists == nil {
		m.removedgrocery_lists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grocery_lists, ids[i])
		m.removedgrocery_lists[ids[i]] = struct{}{}
	}
}

// RemovedGroceryLists returns the removed IDs of the "grocery_lists" edge to the GroceryList entity.
func (m *UserMutation) RemovedGroceryListsIDs() (ids []int) {
	for id := range m.removedgrocery_lists {
		ids = append(ids, id)
	}
	return
}

// GroceryListsIDs returns the "grocery_lists" edge IDs in the mutation.
func (m *UserMutation) GroceryListsIDs() (ids []int) {
	for id := range m.grocery_lists {
		ids = append(ids, id)
	}
	return
}

// ResetGroceryLists resets all changes to the "grocery_lists" edge.
func (m *UserMutation) ResetGroceryLists() {
	m.grocery_lists = nil
	m.clearedgrocery_lists = false
	m.removedgrocery_lists = nil
}

// AddGroceryListShareIDs adds the "grocery_list_shares" edge to the GroceryListShare entity by ids.
func (m *UserMutation) AddGroceryListShareIDs(ids ...int) {
	if m.grocery_list_shares == nil {
		m.grocery_list_shares = make(map[int]struct{})
	}
	for i := range ids {
		m.grocery_list_shares[ids[i]] = struct{}{}
	}
}

// ClearGroceryListShares clears the "grocery_list_shares" edge to the GroceryListShare entity.
func (m *UserMutation) ClearGroceryListShares() {
	m.clearedgrocery_list_shares = true
}

// GroceryListSharesCleared reports if the "grocery_list_shares" edge to the GroceryListShare entity was cleared.
func (m *UserMutation) GroceryListSharesCleared() bool {
	return m.clearedgrocery_list_shares
}

// RemoveGroceryListShareIDs removes the "grocery_list_shares" edge to the GroceryListShare entity by IDs.
func (m *UserMutation) RemoveGroceryListShareIDs(ids ...int) {
	if m.removedgrocery_list_shares == nil {
		m.removedgrocery_list_shares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grocery_list_shares, ids[i])
		m.removedgrocery_list_shares[ids[i]] = struct{}{}
	}
}

// RemovedGroceryListShares returns the removed IDs of the "grocery_list_shares" edge to the GroceryListShare entity.
func (m *UserMutation) RemovedGroceryListSharesIDs() (ids []int) {
	for id := range m.removedgrocery_list_shares {
		ids = append(ids, id)
	}
	return
}

// GroceryListSharesIDs returns the "grocery_list_shares" edge IDs in the mutation.
func (m *UserMutation) GroceryListSharesIDs() (ids []int) {
	for id := range m.grocery_list_shares {
		ids = append(ids, id)
	}
	return
}

// ResetGroceryListShares resets all changes to the "grocery_list_shares" edge.
func (m *UserMutation) ResetGroceryListShares() {
	m.grocery_list_shares = nil
	m.clearedgrocery_list_shares = false
	m.removedgrocery_list_shares = nil
}

// AddMovieListIDs adds the "movie_lists" edge to the MovieList entity by ids.
func (m *UserMutation) AddMovieListIDs(ids ...int) {
	if m.movie_lists == nil {
		m.movie_lists = make(map[int]struct{})
	}
	for i := range ids {
		m.movie_lists[ids[i]] = struct{}{}
	}
}

// ClearMovieLists clears the "movie_lists" edge to the MovieList entity.
func (m *UserMutation) ClearMovieLists() {
	m.clearedmovie_lists = true
}

// MovieListsCleared reports if the "movie_lists" edge to the MovieList entity was cleared.
func (m *UserMutation) MovieListsCleared() bool {
	return m.clearedmovie_lists
}

// RemoveMovieListIDs removes the "movie_lists" edge to the MovieList entity by IDs.
func (m *UserMutation) RemoveMovieListIDs(ids ...int) {
	if m.removedmovie_lists == nil {
		m.removedmovie_lists = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movie_lists, ids[i])
		m.removedmovie_lists[ids[i]] = struct{}{}
	}
}

// RemovedMovieLists returns the removed IDs of the "movie_lists" edge to the MovieList entity.
func (m *UserMutation) RemovedMovieListsIDs() (ids []int) {
	for id := range m.removedmovie_lists {
		ids = append(ids, id)
	}
	return
}

// MovieListsIDs returns the "movie_lists" edge IDs in the mutation.
func (m *UserMutation) MovieListsIDs() (ids []int) {
	for id := range m.movie_lists {
		ids = append(ids, id)
	}
	return
}

// ResetMovieLists resets all changes to the "movie_lists" edge.
func (m *UserMutation) ResetMovieLists() {
	m.movie_lists = nil
	m.clearedmovie_lists = false
	m.removedmovie_lists = nil
}

// AddMovieListShareIDs adds the "movie_list_shares" edge to the MovieListShare entity by ids.
func (m *UserMutation) AddMovieListShareIDs(ids ...int) {
	if m.movie_list_shares == nil {
		m.movie_list_shares = make(map[int]struct{})
	}
	for i := range ids {
		m.movie_list_shares[ids[i]] = struct{}{}
	}
}

// ClearMovieListShares clears the "movie_list_shares" edge to the MovieListShare entity.
func (m *UserMutation) ClearMovieListShares() {
	m.clearedmovie_list_shares = true
}

// MovieListSharesCleared reports if the "movie_list_shares" edge to the MovieListShare entity was cleared.
func (m *UserMutation) MovieListSharesCleared() bool {
	return m.clearedmovie_list_shares
}

// RemoveMovieListShareIDs removes the "movie_list_shares" edge to the MovieListShare entity by IDs.
func (m *UserMutation) RemoveMovieListShareIDs(ids ...int) {
	if m.removedmovie_list_shares == nil {
		m.removedmovie_list_shares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.movie_list_shares, ids[i])
		m.removedmovie_list_shares[ids[i]] = struct{}{}
	}
}

// RemovedMovieListShares returns the removed IDs of the "movie_list_shares" edge to the MovieListShare entity.
func (m *UserMutation) RemovedMovieListSharesIDs() (ids []int) {
	for id := range m.removedmovie_list_shares {
		ids = append(ids, id)
	}
	return
}

// MovieListSharesIDs returns the "movie_list_shares" edge IDs in the mutation.
func (m *UserMutation) MovieListSharesIDs() (ids []int) {
	for id := range m.movie_list_shares {
		ids = append(ids, id)
	}
	return
}

// ResetMovieListShares resets all changes to the "movie_list_shares" edge.
func (m *UserMutation) ResetMovieListShares() {
	m.movie_list_shares = nil
	m.clearedmovie_list_shares = false
	m.removedmovie_list_shares = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.name_changes != nil {
		fields = append(fields, user.FieldNameChanges)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.verified != nil {
		fields = append(fields, user.FieldVerified)
	}
	if m.locked != nil {
		fields = append(fields, user.FieldLocked)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldNameChanges:
		return m.NameChanges()
	case user.FieldEmail:
		return m.Email()
	case user.FieldVerified:
		return m.Verified()
	case user.FieldLocked:
		return m.Locked()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldNameChanges:
		return m.OldNameChanges(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldVerified:
		return m.OldVerified(ctx)
	case user.FieldLocked:
		return m.OldLocked(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldNameChanges:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameChanges(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case user.FieldLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addname_changes != nil {
		fields = append(fields, user.FieldNameChanges)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldNameChanges:
		return m.AddedNameChanges()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldNameChanges:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNameChanges(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldNameChanges:
		m.ResetNameChanges()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldVerified:
		m.ResetVerified()
		return nil
	case user.FieldLocked:
		m.ResetLocked()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.amazon_shares != nil {
		edges = append(edges, user.EdgeAmazonShares)
	}
	if m.amazon_lists != nil {
		edges = append(edges, user.EdgeAmazonLists)
	}
	if m.drinks != nil {
		edges = append(edges, user.EdgeDrinks)
	}
	if m.grocery_lists != nil {
		edges = append(edges, user.EdgeGroceryLists)
	}
	if m.grocery_list_shares != nil {
		edges = append(edges, user.EdgeGroceryListShares)
	}
	if m.movie_lists != nil {
		edges = append(edges, user.EdgeMovieLists)
	}
	if m.movie_list_shares != nil {
		edges = append(edges, user.EdgeMovieListShares)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAmazonShares:
		ids := make([]ent.Value, 0, len(m.amazon_shares))
		for id := range m.amazon_shares {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAmazonLists:
		ids := make([]ent.Value, 0, len(m.amazon_lists))
		for id := range m.amazon_lists {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDrinks:
		ids := make([]ent.Value, 0, len(m.drinks))
		for id := range m.drinks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroceryLists:
		ids := make([]ent.Value, 0, len(m.grocery_lists))
		for id := range m.grocery_lists {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroceryListShares:
		ids := make([]ent.Value, 0, len(m.grocery_list_shares))
		for id := range m.grocery_list_shares {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMovieLists:
		ids := make([]ent.Value, 0, len(m.movie_lists))
		for id := range m.movie_lists {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMovieListShares:
		ids := make([]ent.Value, 0, len(m.movie_list_shares))
		for id := range m.movie_list_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedamazon_shares != nil {
		edges = append(edges, user.EdgeAmazonShares)
	}
	if m.removedamazon_lists != nil {
		edges = append(edges, user.EdgeAmazonLists)
	}
	if m.removeddrinks != nil {
		edges = append(edges, user.EdgeDrinks)
	}
	if m.removedgrocery_lists != nil {
		edges = append(edges, user.EdgeGroceryLists)
	}
	if m.removedgrocery_list_shares != nil {
		edges = append(edges, user.EdgeGroceryListShares)
	}
	if m.removedmovie_lists != nil {
		edges = append(edges, user.EdgeMovieLists)
	}
	if m.removedmovie_list_shares != nil {
		edges = append(edges, user.EdgeMovieListShares)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAmazonShares:
		ids := make([]ent.Value, 0, len(m.removedamazon_shares))
		for id := range m.removedamazon_shares {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAmazonLists:
		ids := make([]ent.Value, 0, len(m.removedamazon_lists))
		for id := range m.removedamazon_lists {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDrinks:
		ids := make([]ent.Value, 0, len(m.removeddrinks))
		for id := range m.removeddrinks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroceryLists:
		ids := make([]ent.Value, 0, len(m.removedgrocery_lists))
		for id := range m.removedgrocery_lists {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroceryListShares:
		ids := make([]ent.Value, 0, len(m.removedgrocery_list_shares))
		for id := range m.removedgrocery_list_shares {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMovieLists:
		ids := make([]ent.Value, 0, len(m.removedmovie_lists))
		for id := range m.removedmovie_lists {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMovieListShares:
		ids := make([]ent.Value, 0, len(m.removedmovie_list_shares))
		for id := range m.removedmovie_list_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedamazon_shares {
		edges = append(edges, user.EdgeAmazonShares)
	}
	if m.clearedamazon_lists {
		edges = append(edges, user.EdgeAmazonLists)
	}
	if m.cleareddrinks {
		edges = append(edges, user.EdgeDrinks)
	}
	if m.clearedgrocery_lists {
		edges = append(edges, user.EdgeGroceryLists)
	}
	if m.clearedgrocery_list_shares {
		edges = append(edges, user.EdgeGroceryListShares)
	}
	if m.clearedmovie_lists {
		edges = append(edges, user.EdgeMovieLists)
	}
	if m.clearedmovie_list_shares {
		edges = append(edges, user.EdgeMovieListShares)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAmazonShares:
		return m.clearedamazon_shares
	case user.EdgeAmazonLists:
		return m.clearedamazon_lists
	case user.EdgeDrinks:
		return m.cleareddrinks
	case user.EdgeGroceryLists:
		return m.clearedgrocery_lists
	case user.EdgeGroceryListShares:
		return m.clearedgrocery_list_shares
	case user.EdgeMovieLists:
		return m.clearedmovie_lists
	case user.EdgeMovieListShares:
		return m.clearedmovie_list_shares
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAmazonShares:
		m.ResetAmazonShares()
		return nil
	case user.EdgeAmazonLists:
		m.ResetAmazonLists()
		return nil
	case user.EdgeDrinks:
		m.ResetDrinks()
		return nil
	case user.EdgeGroceryLists:
		m.ResetGroceryLists()
		return nil
	case user.EdgeGroceryListShares:
		m.ResetGroceryListShares()
		return nil
	case user.EdgeMovieLists:
		m.ResetMovieLists()
		return nil
	case user.EdgeMovieListShares:
		m.ResetMovieListShares()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
